==1 ..................................==========
==1-hello.go========================
package main //1

import "fmt" //2

func main() { //3  
    fmt.Println("Hello World") //4
}

==2 ..................................==========
==constants.go========================
package main

import (
	"fmt"
	"math"
)

func main() {
	const1()
	const2()
	const3_string()
	const4_boolean()
	const5_numeric()
	const6_numeric_expressions()
}

func const1() {
	const a = 55 //allowed
	//a = 89 //reassignment not allowed
	fmt.Println(a)
}

func const2() {
	var a = math.Sqrt(4) //allowed
	//const b = math.Sqrt(4)//not allowed
	fmt.Println(a)
}

func const3_string() {

	const hello = "Hello World"
	fmt.Printf(hello)
	//hello = "modify"

	var defaultName = "Sam" //allowed
	fmt.Printf("\ntype %T value %v", defaultName, defaultName)

	type myString string
	var customName myString = "Sam" //allowed
	customName = "defaultName"      //not allowed

	fmt.Printf("\ntype %T value %v", customName, customName)
}

func const4_boolean() {

	fmt.Println()
	const trueConst = true
	type myBool bool
	var defaultBool = trueConst       //allowed
	var customBool myBool = trueConst //allowed
	//defaultBool = customBool //not allowed
	fmt.Println(trueConst, defaultBool, customBool)
}

func const5_numeric() {

	const a = 5
	var intVar int = a
	var int32Var int32 = a
	var float64Var float64 = a
	var complex64Var complex64 = a
	fmt.Println("intVar", intVar, "\nint32Var", int32Var, "\nfloat64Var", float64Var, "\ncomplex64Var", complex64Var)

	var i = 5
	var f = 5.6
	var c = 5 + 6i
	fmt.Printf("i's type %T, f's type %T, c's type %T", i, f, c)
}

func const6_numeric_expressions() {

	var a = 5.9 / 8
	fmt.Printf("\na's type %T value %v", a, a)
}

==type.go========================
/*
int8: represents 8 bit signed integers
size: 8 bits
range: -128 to 127

int16: represents 16 bit signed integers
size: 16 bits
range: -32768 to 32767

int32: represents 32 bit signed integers
size: 32 bits
range: -2147483648 to 2147483647

int64: represents 64 bit signed integers
size: 64 bits
range: -9223372036854775808 to 9223372036854775807

int: represents 32 or 64 bit integers depending on the underlying platform. You should generally be using int to represent integers unless there is a need to use a specific sized integer.
size: 32 bits in 32 bit systems and 64 bit in 64 bit systems.
range: -2147483648 to 2147483647 in 32 bit systems and -9223372036854775808 to 9223372036854775807 in 64 bit systems

---------------------------

uint8: represents 8 bit unsigned integers
size: 8 bits
range: 0 to 255

uint16: represents 16 bit unsigned integers
size: 16 bits
range: 0 to 65535

uint32: represents 32 bit unsigned integers
size: 32 bits
range: 0 to 4294967295

uint64: represents 64 bit unsigned integers
size: 64 bits
range: 0 to 18446744073709551615

uint : represents 32 or 64 bit unsigned integers depending on the underlying platform.
size : 32 bits in 32 bit systems and 64 bits in 64 bit systems.
range : 0 to 4294967295 in 32 bit systems and 0 to 18446744073709551615 in 64 bit systems

byte is an alias of uint8
rune is an alias of int32

*/

package main

import (
	"fmt"
	"unsafe"
)

func main() {
	type1_bool()
	type2_signed_integers()
	type3_signed_integers()
	type4_unsigned_integers()
	type5_floating_point()
	type6_complex()
	type7_string()
	type8_conversion()
}

func type1_bool() {
	a := true
	b := false
	fmt.Println("a:", a, "b:", b)
	c := a && b
	fmt.Println("c:", c)
	d := a || b
	fmt.Println("d:", d)
}

func type2_signed_integers() {
	var a int = 89
	b := 95
	fmt.Println("value of a is", a, "and b is", b)
}

func type3_signed_integers() {
	var a int = 89
	b := 95
	fmt.Println("value of a is", a, "and b is", b)
	fmt.Printf("type of a is %T, size of a is %d", a, unsafe.Sizeof(a))   //type and size of a
	fmt.Printf("\ntype of b is %T, size of b is %d", b, unsafe.Sizeof(b)) //type and size of b
}

func type4_unsigned_integers() {
	var a int = 89
	b := 95
	fmt.Println("\nvalue of a is", a, "and b is", b)
	fmt.Printf("type of a is %T, size of a is %d", a, unsafe.Sizeof(a))   //type and size of a
	fmt.Printf("\ntype of b is %T, size of b is %d", b, unsafe.Sizeof(b)) //type and size of b
}

func type5_floating_point() {
	a, b := 5.67, 8.97
	fmt.Printf("\ntype of a %T b %T\n", a, b)
	sum := a + b
	diff := a - b
	fmt.Println("sum", sum, "diff", diff)

	no1, no2 := 56, 89
	fmt.Println("sum", no1+no2, "diff", no1-no2)
}

func type6_complex() {
	c1 := complex(5, 7)
	c2 := 8 + 27i
	cadd := c1 + c2
	fmt.Println("sum:", cadd)
	cmul := c1 * c2
	fmt.Println("product:", cmul)
}

func type7_string() {
	first := "manoj"
	last := "kumar"
	name := first + " " + last
	fmt.Println("My name is", name)
}

func type8_conversion() {
	i := 55   //int
	j := 67.8 //float64
	//sum := i + j //int + float64 not allowed
	sum1 := i + int(j)

	sum2 := float64(i) + j
	fmt.Println(sum1, sum2)
}

==variables.go========================
package main

import "fmt"
import "math"

func main() {
	var1()
	var2()
	var3()
	var4()
	var5()
	var6()
	var7()
	var8()
	var9()

}

func var1() {
	var age int // variable declaration
	fmt.Println("my age is", age)
}

func var2() {
	var age int // variable declaration
	fmt.Println("my age is ", age)
	age = 29 //assignment
	fmt.Println("my age is", age)
	age = 54 //assignment
	fmt.Println("my new age is", age)
}

func var3() {
	var age int = 29 // variable declaration with initial value

	fmt.Println("my age is", age)
}

func var4() {
	var age = 29 // type will be inferred

	fmt.Println("my age is", age)
}

func var5() {
	var width, height int = 100, 50 //declaring multiple variables

	fmt.Println("width is", width, "height is", height)
}

func var6() {
	var (
		name   = "naveen"
		age    = 29
		height int
	)
	fmt.Println("my name is", name, ", age is", age, "and height is", height)
}

func var7() {
	name, age := "naveen", 29 //short hand declaration

	fmt.Println("my name is", name, "age is", age)
}

func var8() {
	a, b := 20, 30 // declare variables a and b
	fmt.Println("a is", a, "b is", b)
	b, c := 40, 50 // b is already declared but c is new
	fmt.Println("b is", b, "c is", c)
	b, c = 80, 90 // assign new values to already declared variables b and c
	fmt.Println("changed b is", b, "c is", c)
}

func var9() {
	a, b := 145.8, 543.8
	c := math.Min(a, b)
	fmt.Println("minimum value is ", c)
}


==3 ..................................==========
==lib.go================================golangbot2\3-function-pkg\geometry\rectangle
package rectangle

import "math"  
import "fmt"

/*
 * init function added
 */
func init() {  
    fmt.Println("lib package initialized")
}
func Area(len, wid float64) float64 {  
    area := len * wid
    return area
}

func Diagonal(len, wid float64) float64 {  
    diagonal := math.Sqrt((len * len) + (wid * wid))
    return diagonal
}



==ex1-basic.go========================
package main

import (  
    "fmt"
)

func calculateBill(price, no int) int {  
    var totalPrice = price * no
    return totalPrice
}
func main() {  
    price, no := 90, 6
    totalPrice := calculateBill(price, no)
    fmt.Println("Total price is", totalPrice)
}
==ex1-multiple.go========================
package main

import (  
    "fmt"
)

func rectProps(length, width float64)(float64, float64) {  
    var area = length * width
    var perimeter = (length + width) * 2
    return area, perimeter
}

func main() {  
     area, perimeter := rectProps(10.8, 5.6)
    fmt.Printf("Area %f Perimeter %f", area, perimeter) 
}
==ex1-multiple_.go========================
package main

import (  
    "fmt"
)

func rectProps(length, width float64) (float64, float64) {  
    var area = length * width
    var perimeter = (length + width) * 2
    return area, perimeter
}
func main() {  
    area, _ := rectProps(10.8, 5.6) // perimeter is discarded
    fmt.Printf("Area %f ", area)
}
==go.mod========================
module golangbot2/3-function-pkg

go 1.13

==pkg1.go========================
//geometry.go
package main 

import (  
    "fmt"
    "golangbot2/3-function-pkg/geometry/rectangle" //importing custom package
)

func main() {  
    var rectLen, rectWidth float64 = 6, 7
    fmt.Println("Geometrical shape properties")
        /*Area function of rectangle package used
        */
    fmt.Printf("area of rectangle %.2f\n", rectangle.Area(rectLen, rectWidth))
        /*Diagonal function of rectangle package used
        */
    fmt.Printf("diagonal of the rectangle %.2f ",rectangle.Diagonal(rectLen, rectWidth))
}
==pkg2.go========================
//geometry.go
package main 

import (  
    "fmt"
    "golangbot2/3-function-pkg/geometry/rectangle" //importing custom package
    "log"
)
/*
 * 1. package variables
*/
var rectLen, rectWidth float64 = 6, 7 

/*
*2. init function to check if length and width are greater than zero
*/
func init() {  
    println("main package initialized")
    if rectLen < 0 {
        log.Fatal("length is less than zero")
    }
    if rectWidth < 0 {
        log.Fatal("width is less than zero")
    }
}

func main() {  
    fmt.Println("Geometrical shape properties")
    fmt.Printf("area of rectangle %.2f\n", rectangle.Area(rectLen, rectWidth))
    fmt.Printf("diagonal of the rectangle %.2f ",rectangle.Diagonal(rectLen, rectWidth))
}

==4 ..................................==========
==for1.go========================
package main

import (  
    "fmt"
)

func main() {  
    for i := 1; i <= 10; i++ {
        fmt.Printf(" %d",i)
    }
}

==for2-break.go========================
package main

import (  
    "fmt"
)

func main() {  
    for i := 1; i <= 10; i++ {
        if i > 5 {
            break //loop is terminated if i > 5
        }
        fmt.Printf("%d ", i)
    }
    fmt.Printf("\nline after for loop")
}
==for3-continue.go========================
package main

import (  
    "fmt"
)

func main() {  
    for i := 1; i <= 10; i++ {
        if i%2 == 0 {
            continue
        }
        fmt.Printf("%d ", i)
    }
}
==for4-nested.go========================
package main

import (  
    "fmt"
)

func main() {  
    n := 5
    for i := 0; i < n; i++ {
        for j := 0; j <= i; j++ {
            fmt.Print("*")
        }
        fmt.Println()
    }
}
==for5-label.go========================
package main

import (  
    "fmt"
)

func main() {  
outer:  
    for i := 0; i < 3; i++ {
        for j := 1; j < 4; j++ {
            fmt.Printf("i = %d , j = %d\n", i, j)
            if i == j {
                break outer
            }
        }

    }
}
==for6.go========================
package main

import (  
    "fmt"
)

func main() {  
	main0()
	main1()
	main2()
	
	//infinite loop
	//main3()
	
}

func main0() {  
    i := 0
    for ;i <= 10; { // initialisation and post are omitted
        fmt.Printf("%d ", i)
        i += 2
    }
}

func main1() {  
    i := 0
    for i <= 10 { //semicolons are ommitted and only condition is present
        fmt.Printf("%d ", i)
        i += 2
    }
}

func main2() {  
    for no, i := 10, 1; i <= 10 && no <= 19; i, no = i+1, no+1 { //multiple initialisation and increment
        fmt.Printf("%d * %d = %d\n", no, i, no*i)
    }

}


func main3() {  
    for {
        fmt.Println("Hello World")
    }
}
==if1.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 10
    if num % 2 == 0 { //checks if number is even
        fmt.Println("the number is even") 
    }  else {
        fmt.Println("the number is odd")
    }
}
==if2.go========================
package main

import (  
    "fmt"
)

func main() {  
    if num := 10; num % 2 == 0 { //checks if number is even
        fmt.Println(num,"is even") 
    }  else {
        fmt.Println(num,"is odd")
    }
}
==if3.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 99
    if num <= 50 {
        fmt.Println("number is less than or equal to 50")
    } else if num >= 51 && num <= 100 {
        fmt.Println("number is between 51 and 100")
    } else {
        fmt.Println("number is greater than 100")
    }

}
==if4-error.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 10
    if num % 2 == 0 { //checks if number is even
        fmt.Println("the number is even") 
    }  
    else {
        fmt.Println("the number is odd")
    }
}

// need in same line
//} else {
==readme.txt========================
if condition {  
}


if condition {  
} else if condition {
} else {
}


if statement; condition {  
}

++++++++++++++++++++++

for initialisation; condition; post {  
}

-----

for {  
}
==switch1-basic.go========================
package main

import (  
    "fmt"
)

func main() {
 main1()
 main2()		//shows error
 main3()
 
}

///////////////////

func main1() {  
    finger := 4
    switch finger {
    case 1:
        fmt.Println("Thumb")
    case 2:
        fmt.Println("Index")
    case 3:
        fmt.Println("Middle")
    case 4:
        fmt.Println("Ring")
    case 5:
        fmt.Println("Pinky")

    }
}

func main2() {  
    finger := 4
    switch finger {
    case 1:
        fmt.Println("Thumb")
    case 2:
        fmt.Println("Index")
    case 3:
        fmt.Println("Middle")
    case 4:
        fmt.Println("Ring")
	//duplicate case	
    //case 4: fmt.Println("Another Ring")
	
    case 5:
        fmt.Println("Pinky")

    }
}

func main3() {  
    switch finger := 8; finger {
    case 1:
        fmt.Println("Thumb")
    case 2:
        fmt.Println("Index")
    case 3:
        fmt.Println("Middle")
    case 4:
        fmt.Println("Ring")
    case 5:
        fmt.Println("Pinky")
    default: //default case
        fmt.Println("incorrect finger number")
    }
}
==switch2-multi-exp.go========================
package main

import (  
    "fmt"
)

func main() {  
    letter := "i"
    switch letter {
    case "a", "e", "i", "o", "u": //multiple expressions in case
        fmt.Println("vowel")
    default:
        fmt.Println("not a vowel")
    }
}
==switch3-no-exp.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 75
    switch { // expression is omitted => true
    case num >= 0 && num <= 50:
        fmt.Println("num is greater than 0 and less than 50")
    case num >= 51 && num <= 100:
        fmt.Println("num is greater than 51 and less than 100")
    case num >= 101:
        fmt.Println("num is greater than 100")
    }

}
==switch4-fallthrough.go========================
package main

import (  
    "fmt"
)

func number() int {  
        num := 15 * 5 
        return num
}

func main() {

    switch num := number(); { //num is not a constant
    case num < 50:
        fmt.Printf("%d is lesser than 50\n", num)
        fallthrough
    case num < 100:
        fmt.Printf("%d is lesser than 100\n", num)
        fallthrough
    case num < 200:
        fmt.Printf("%d is lesser than 200", num)
    }

}
==for1.go========================
package main

import (  
    "fmt"
)

func main() {  
    for i := 1; i <= 10; i++ {
        fmt.Printf(" %d",i)
    }
}

==for2-break.go========================
package main

import (  
    "fmt"
)

func main() {  
    for i := 1; i <= 10; i++ {
        if i > 5 {
            break //loop is terminated if i > 5
        }
        fmt.Printf("%d ", i)
    }
    fmt.Printf("\nline after for loop")
}
==for3-continue.go========================
package main

import (  
    "fmt"
)

func main() {  
    for i := 1; i <= 10; i++ {
        if i%2 == 0 {
            continue
        }
        fmt.Printf("%d ", i)
    }
}
==for4-nested.go========================
package main

import (  
    "fmt"
)

func main() {  
    n := 5
    for i := 0; i < n; i++ {
        for j := 0; j <= i; j++ {
            fmt.Print("*")
        }
        fmt.Println()
    }
}
==for5-label.go========================
package main

import (  
    "fmt"
)

func main() {  
outer:  
    for i := 0; i < 3; i++ {
        for j := 1; j < 4; j++ {
            fmt.Printf("i = %d , j = %d\n", i, j)
            if i == j {
                break outer
            }
        }

    }
}
==for6.go========================
package main

import (  
    "fmt"
)

func main() {  
	main0()
	main1()
	main2()
	
	//infinite loop
	//main3()
	
}

func main0() {  
    i := 0
    for ;i <= 10; { // initialisation and post are omitted
        fmt.Printf("%d ", i)
        i += 2
    }
}

func main1() {  
    i := 0
    for i <= 10 { //semicolons are ommitted and only condition is present
        fmt.Printf("%d ", i)
        i += 2
    }
}

func main2() {  
    for no, i := 10, 1; i <= 10 && no <= 19; i, no = i+1, no+1 { //multiple initialisation and increment
        fmt.Printf("%d * %d = %d\n", no, i, no*i)
    }

}


func main3() {  
    for {
        fmt.Println("Hello World")
    }
}
==if1.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 10
    if num % 2 == 0 { //checks if number is even
        fmt.Println("the number is even") 
    }  else {
        fmt.Println("the number is odd")
    }
}
==if2.go========================
package main

import (  
    "fmt"
)

func main() {  
    if num := 10; num % 2 == 0 { //checks if number is even
        fmt.Println(num,"is even") 
    }  else {
        fmt.Println(num,"is odd")
    }
}
==if3.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 99
    if num <= 50 {
        fmt.Println("number is less than or equal to 50")
    } else if num >= 51 && num <= 100 {
        fmt.Println("number is between 51 and 100")
    } else {
        fmt.Println("number is greater than 100")
    }

}
==if4-error.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 10
    if num % 2 == 0 { //checks if number is even
        fmt.Println("the number is even") 
    }  
    else {
        fmt.Println("the number is odd")
    }
}

// need in same line
//} else {
==readme.txt========================
if condition {  
}


if condition {  
} else if condition {
} else {
}


if statement; condition {  
}

++++++++++++++++++++++

for initialisation; condition; post {  
}

-----

for {  
}
==switch1-basic.go========================
package main

import (  
    "fmt"
)

func main() {
 main1()
 main2()		//shows error
 main3()
 
}

///////////////////

func main1() {  
    finger := 4
    switch finger {
    case 1:
        fmt.Println("Thumb")
    case 2:
        fmt.Println("Index")
    case 3:
        fmt.Println("Middle")
    case 4:
        fmt.Println("Ring")
    case 5:
        fmt.Println("Pinky")

    }
}

func main2() {  
    finger := 4
    switch finger {
    case 1:
        fmt.Println("Thumb")
    case 2:
        fmt.Println("Index")
    case 3:
        fmt.Println("Middle")
    case 4:
        fmt.Println("Ring")
	//duplicate case	
    //case 4: fmt.Println("Another Ring")
	
    case 5:
        fmt.Println("Pinky")

    }
}

func main3() {  
    switch finger := 8; finger {
    case 1:
        fmt.Println("Thumb")
    case 2:
        fmt.Println("Index")
    case 3:
        fmt.Println("Middle")
    case 4:
        fmt.Println("Ring")
    case 5:
        fmt.Println("Pinky")
    default: //default case
        fmt.Println("incorrect finger number")
    }
}
==switch2-multi-exp.go========================
package main

import (  
    "fmt"
)

func main() {  
    letter := "i"
    switch letter {
    case "a", "e", "i", "o", "u": //multiple expressions in case
        fmt.Println("vowel")
    default:
        fmt.Println("not a vowel")
    }
}
==switch3-no-exp.go========================
package main

import (  
    "fmt"
)

func main() {  
    num := 75
    switch { // expression is omitted => true
    case num >= 0 && num <= 50:
        fmt.Println("num is greater than 0 and less than 50")
    case num >= 51 && num <= 100:
        fmt.Println("num is greater than 51 and less than 100")
    case num >= 101:
        fmt.Println("num is greater than 100")
    }

}
==switch4-fallthrough.go========================
package main

import (  
    "fmt"
)

func number() int {  
        num := 15 * 5 
        return num
}

func main() {

    switch num := number(); { //num is not a constant
    case num < 50:
        fmt.Printf("%d is lesser than 50\n", num)
        fallthrough
    case num < 100:
        fmt.Printf("%d is lesser than 100\n", num)
        fallthrough
    case num < 200:
        fmt.Printf("%d is lesser than 200", num)
    }

}

==5 ..................................==========
==5-array.go========================
/*
Arrays
An array is a collection of elements that belong to the same type. For example the collection of integers 5, 8, 9, 79, 76 form an array. Mixing values of different types, for example an array that contains both strings and integers is not allowed in Go.
*/

package main

import (  
    "fmt"
)


func main () {
	Array1();	
	Array2();	
	Array3();	
	Array_iteration_for();
	Array_iteration_range();
	Array_multidimensional();	
}

func Array1() {  
    fmt.Println()
    var a [3]int //int array with length 3
    fmt.Println(a)
	

    a[0] = 12 // array index starts at 0
    a[1] = 78
    a[2] = 50
    fmt.Println(a)	
	
    b := [3]int{12, 78, 50} // short hand declaration to create array
    fmt.Println(b)	
	
    c := [3]int{12} 
    fmt.Println(c)	
	
    d := [...]int{12, 78, 50} // ... makes the compiler determine the length
    fmt.Println(d)	
	
  
    e := [3]int{5, 78, 8}
    //var f [5]int   //not working - The size of the array is a part of the type
	var f [3]int
    f = e //not possible since [3]int and [5]int are distinct types
    fmt.Println(e,f)	

	//array length
	g := [...]float64{67.7, 89.8, 21, 78}
    fmt.Println("length of g is",len(g))
}

func Array2() {  
    a := [...]string{"USA", "China", "India"}
    b := a // a copy of a is assigned to b
    b[0] = "UK"
    fmt.Println("a is ", a)
    fmt.Println("b is ", b) 
}

func changeLocal(num [5]int) {  
    num[0] = 27
    fmt.Println("inside function ", num)

}

func Array3() {  
    num := [...]int{5, 6, 7, 8, 8}
    fmt.Println("before passing to function ", num)
    changeLocal(num) //num is passed by value
    fmt.Println("after passing to function ", num)
}

func Array_iteration_for() {  
    a := [...]float64{67.7, 89.8, 21, 78}
    for i := 0; i < len(a); i++ { //looping from 0 to the length of the array
        fmt.Printf("%d th element of a is %.2f\n", i, a[i])
    }
}

func Array_iteration_range() {    
    a := [...]float64{67.7, 89.8, 21, 78}
    sum := float64(0)
    for i, v := range a {//range returns both the index and value
        fmt.Printf("%d the element of a is %.2f\n", i, v)
        sum += v
    }
    fmt.Println("\nsum of all elements of a",sum)	
	
	for _, v := range a { //ignores index  
	  fmt.Printf("element : %.2f\n", v)
	}		
}	

func printarray(a [3][2]string) {  
    for _, v1 := range a {
        for _, v2 := range v1 {
            fmt.Printf("%s ", v2)
        }
        fmt.Printf("\n")
    }
}

func Array_multidimensional() {  
    a := [3][2]string{
        {"lion", "tiger"},
        {"cat", "dog"},
        {"pigeon", "peacock"}, //this comma is necessary. The compiler will complain if you omit this comma
    }
    printarray(a)
    var b [3][2]string
    b[0][0] = "apple"
    b[0][1] = "samsung"
    b[1][0] = "microsoft"
    b[1][1] = "google"
    b[2][0] = "AT&T"
    b[2][1] = "T-Mobile"
    fmt.Printf("\n")
    printarray(b)
}


==5-array.txt========================
1. Using var keyword: In Go language, an array is created using the var keyword of a particular type with name, size, and elements.

Syntax:
Var array_name[length]Type
or
var array_name[length]Typle{item1, item2, item3, ...itemN}



2. Using shorthand declaration: In Go language, arrays can also declare using shorthand declaration. It is more flexible than the above declaration.

Syntax:

array_name:= [length]Type{item1, item2, item3,...itemN}

++++++++++++++++
1 . In an array, if an array does not initialized explicitly, then the default value of this array is 0.
var myarr[2]int => [0 0]
 
2. In an array, you can find the length of the array using len() method as shown below:
arr1:= [3]int{9,7,6} //len(arr1)
arr2:= [...]int{9,7,6,4,5,3,2,4} //len(arr2)


3. In an array, if ellipsis ... become visible at the place of length, then the length of the array is determined by the initialized elements. As shown in the below example: 
myarray:= [...]string{"aaa", "bbb", "ccc"} 
fmt.Println("Elements of the array: ", myarray) 

4. In an array, you are allowed to iterate over the range of the elements of the array. As shown in the below example: 
myarray:= [...]int{29, 79, 49, 39, 
                   20, 49, 48, 49} 
  
// Iterate array using for loop 
for x:=0; x < len(myarray); x++{ 
fmt.Printf("%d\n", myarray[x]) 
} 

5. In Go language, an array is of value type not of reference type. So when the array is assigned to a new variable, then the changes made in the new variable do not affect the original array. As shown in the below example: 

my_array:= [...]int{10, 20, 30, 40, 50} 
fmt.Println("New array(before):", new_array) 
new_array[0] = 50 
fmt.Println("New array(After):", new_array) 


6. In an array, if the element type of the array is comparable, then the array type is also comparable. So we can directly compare two arrays using == operator. As shown in the below example:
Example:
  
arr1:= [3]int{9,7,6} 
arr2:= [...]int{9,7,6} 
arr3:= [3]int{9,5,3} 
  
// Comparing arrays using == operator 
fmt.Println(arr1==arr2) 
fmt.Println(arr2==arr3) 
fmt.Println(arr1==arr3) 

==5-slice.go========================
/*Slices
A slice is a convenient, flexible and powerful wrapper on top of an array. Slices do not own any data on their own. They are the just references to existing arrays.
*/

package main

import (  
    "fmt"
)

func main() {   

	Slice1();
	Slice2();	
	Slice3();	
	Slice4();	
	Slice_make();
	Slice_append();
	Slice_nil();
	Slice_in_function();
	Slice_multidimensional();
	Slice_memory_optimisation();    
}


func Slice1() {  
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4] //creates a slice from a[1] to a[3]
    fmt.Println(b)
	
    c := []int{6, 7, 8} //creates and returns a slice reference
    fmt.Println(c)	
	
	/*A slice does not own any data of its own. It is just a representation of the underlying array. 
	Any modifications done to the slice will be reflected in the underlying array.
	*/
    darr := [...]int{1,2,3,4,5,6,7,8,9}
    dslice := darr[2:5]
    fmt.Println("array before",darr)
    for i := range dslice {
        dslice[i]++
    }
    fmt.Println("array after",darr) 	
}

func Slice2() {  
    numa := [3]int{78, 79 ,80}
    nums1 := numa[:] //creates a slice which contains all elements of the array
    nums2 := numa[:]
    fmt.Println("array before change 1",numa)
    nums1[0] = 100
    fmt.Println("array after modification to slice nums1", numa)
    nums2[1] = 101
    fmt.Println("array after modification to slice nums2", numa)
}

/*
length and capacity of a slice
The length of the slice is the number of elements in the slice. 
The capacity of the slice is the number of elements in the underlying array starting from the index from which the slice is created.
*/
func Slice3() { 
	fmt.Println()
    fruitarray := [...]string{"apple", "orange", "grape", "mango", "banana"}
    fruitslice := fruitarray[2:4]
    fmt.Printf("length of slice %d capacity %d", len(fruitslice), cap(fruitslice)) //length of is 2(grape,mango) and capacity is 3(grape,mango,banana)
}

func Slice4() { 
	fmt.Println()
    fruitarray := [...]string{"apple", "orange", "grape", "mango", "water melon", "pine apple", "chikoo"}
    fruitslice := fruitarray[1:3]
    fmt.Printf("length of slice %d capacity %d\n", len(fruitslice), cap(fruitslice)) //length of is 2 and capacity is 6
    fruitslice = fruitslice[:cap(fruitslice)] //re-slicing furitslice till its capacity
    fmt.Println("After re-slicing length is",len(fruitslice), "and capacity is",cap(fruitslice))
}

/*
creating a slice using make
func make([]T, len, cap) []T can be used to create a slice by passing the type, length and capacity. The capacity parameter is optional and defaults to the length. The make function creates an array and returns a slice reference to it.
*/

func Slice_make() {  
    i := make([]int, 5, 5)
    fmt.Println(i)
}
func Slice_append() {  
    cars := []string{"Ferrari", "Honda", "Ford"}
    fmt.Println("cars:", cars, "has old length", len(cars), "and capacity", cap(cars)) //capacity of cars is 3
    cars = append(cars, "Toyota")
    fmt.Println("cars:", cars, "has new length", len(cars), "and capacity", cap(cars)) //capacity of cars is doubled to 6
	
	for k,v := range cars {
        fmt.Println(k,v);
    }	
	
    veggies := []string{"potatoes","tomatoes","brinjal"}
    fruits := []string{"oranges","apples"}
    food := append(veggies, fruits...)
    fmt.Println("food:",food)	
}

func Slice_nil() {  
    var names []string //zero value of a slice is nil
    if names == nil {
        fmt.Println("slice is nil going to append")
        names = append(names, "John", "Sebastian", "Vinay")
        fmt.Println("names contents:",names)
    }
}

func subtactOne(numbers []int) {  
    for i := range numbers {
        numbers[i] -= 2
    }

}
func Slice_in_function() {  
    nos := []int{8, 7, 6}
    fmt.Println("slice before function call", nos)
    subtactOne(nos)                               //function modifies the slice
    fmt.Println("slice after function call", nos) //modifications are visible outside
}

func Slice_multidimensional() {  
     pls := [][]string {
            {"C", "C++"},
            {"JavaScript"},
            {"Go", "Rust"},
            }
    for _, v1 := range pls {
        for _, v2 := range v1 {
            fmt.Printf("%s ", v2)
        }
        fmt.Printf("\n")
    }
}

func countries() []string {  
    countries := []string{"USA", "Singapore", "Germany", "India", "Australia"}
    neededCountries := countries[:len(countries)-2]
    countriesCpy := make([]string, len(neededCountries))
    copy(countriesCpy, neededCountries) //copies neededCountries to countriesCpy
    return countriesCpy
}
func Slice_memory_optimisation() {  
    countriesNeeded := countries()
    fmt.Println(countriesNeeded)
}

==5-slice.txt========================
[]T
or 
[]T{}
or 
[]T{value1, value2, value3, ...value n}

Here, T is the type of the elements. For example:

var my_slice[]int

------
A slice contains three components:

    Pointer: The pointer is used to points to the first element of the array that is accessible through the slice. Here, it is not necessary that the pointed element is the first element of the array.
    Length: The length is the total number of elements present in the array.
    Capacity: The capacity represents the maximum size upto which it can expand.



How to create and initialize a Slice?

Using slice literal
var my_slice_1 = []string{"Geeks", "for", "Geeks"}

Using an Array - slice is the reference of the array
array_name[low:high]

Using already Existing Slice: 
slice_name[low:high]


Using make() function
func make([]T, len, cap) []T
==5-variadic-functions.go========================
package main

import (  
    "fmt"
)

func main() {
	//variadic_function1()
	///variadic_function2()
	//variadic_string1()
	variadic_string2()
}

func find(num int, nums ...int) {  
    fmt.Printf("type of nums is %T\n", nums)
    found := false
    for i, v := range nums {
        if v == num {
            fmt.Println(num, "found at index", i, "in", nums)
            found = true
        }
    }
    if !found {
        fmt.Println(num, "not found in ", nums)
    }
    fmt.Printf("\n")
}
func variadic_function1() {  
    find(89, 89, 90, 95)
    find(45, 56, 67, 45, 90, 109)
    find(78, 38, 56, 98)
    find(87)
}

 
func variadic_function2() {  
    nums := []int{89, 90, 95}
    //find(89, nums) //compilation error : we are passing a slice to a function which expects a variable number of arguments
	find(89, nums...)
}
////////////////////////////////////////////////
func change(s ...string) {  
    s[0] = "Go"
}

func variadic_string1() {  
    welcome := []string{"hello", "world"}
    change(welcome...)
    fmt.Println(welcome)
}
///////////////////////////////////////////////
func change2(s ...string) {  
    s[0] = "Go"
    s = append(s, "playground")
    fmt.Println(s)
}

func variadic_string2() {
	welcome := []string{"hello", "world"}
	fmt.Println(welcome)
	change2(welcome...)
	fmt.Println(welcome)
}

==6a ..................................==========
==ex1-basic.go========================
package main

import (  
    "fmt"
)

func main() {  
    var personSalary map[string]int
    if personSalary == nil {
        fmt.Println("map is nil. Going to make one.")
        personSalary = make(map[string]int)
    }
}
==ex10-map-nil.go========================
package main

import (
	"fmt"
)

func main() {

	map_nil()
	map_not_nil()

}

func map_nil() {
	var map1 map[string]int

	/*
		//Invalid operation: map1 == map2 (map can only be compared to nil).
		map2 := map[string]int{"three" : 3}
		if map1 == map2 {
		}
	*/

	fmt.Println(map1) //map[]
	if map1 == nil {
		fmt.Println("map is empty") //map is empty
	}
}

func map_not_nil() {

	map1 := make(map[string]int)
	//map1 := map[string]int{}

	fmt.Println(map1) //map[]
	if map1 == nil {
		fmt.Println("map is empty") //not printed
	}

}

==ex11-map-compare.go========================
package main

import "fmt"
import "reflect"

func main() {

	/*
		var map1 map[string]int
			//Invalid operation: map1 == map2 (map can only be compared to nil).
			map2 := map[string]int{"three" : 3}
			if map1 == map2 {
			}
	*/

	map1 := make(map[string]int)
	map2 := make(map[string]int)

	map1["aaa"] = 10
	map2["aaa"] = 10

	eq := reflect.DeepEqual(map1, map2)
	if eq {
		fmt.Println("Two maps are equal")
	} else {
		fmt.Println("Two maps are not equal")
	}

}

==ex2-make.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := make(map[string]int)
    personSalary["steve"] = 12000
    personSalary["jamie"] = 15000
    personSalary["mike"] = 9000
    fmt.Println("personSalary map contents:", personSalary)
}
==ex3-without-make.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := map[string]int {
        "steve": 12000,
        "jamie": 15000,
    }
    personSalary["mike"] = 9000
    fmt.Println("personSalary map contents:", personSalary)
}
==ex4-accessing.go========================
package main

import (  
    "fmt"
)


func main() {  
    personSalary := map[string]int{
        "steve": 12000,
        "jamie": 15000,
    }
    personSalary["mike"] = 9000
    employee := "jamie"
    fmt.Println("Salary of", employee, "is", personSalary[employee])
    fmt.Println("Salary of joe is", personSalary["joe"])
}
==ex5-in_array.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := map[string]int{
        "steve": 12000,
        "jamie": 15000,
    }
    personSalary["mike"] = 9000
    newEmp := "joe"
    value, ok := personSalary[newEmp]
    if ok == true {
        fmt.Println("Salary of", newEmp, "is", value)
    } else {
        fmt.Println(newEmp,"not found")
    }

}
==ex6_iterate.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := map[string]int{
        "steve": 12000,
        "jamie": 15000,
    }
    personSalary["mike"] = 9000
    fmt.Println("All items of a map")
    for key, value := range personSalary {
        fmt.Printf("personSalary[%s] = %d\n", key, value)
    }

}
==ex7-delete-item.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := map[string]int{
        "aaa": 10,
        "bbb": 20,
    }
    personSalary["ccc"] = 30
    fmt.Println("map before deletion", personSalary)
    delete(personSalary, "bbb")
    fmt.Println("map after deletion", personSalary)

}
==ex8-map-len.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := map[string]int{
        "aa": 10,
        "bb": 20,
    }
    personSalary["cc"] = 30
    fmt.Println("length is", len(personSalary))

}
==ex9-map-reference-type.go========================
package main

import (  
    "fmt"
)

func main() {  
    personSalary := map[string]int{
        "aa": 10,
        "bb": 20,
    }
    personSalary["cc"] = 30
    fmt.Println("Original person salary", personSalary)
    newPersonSalary := personSalary
    newPersonSalary["dd"] = 40
    fmt.Println("Person salary changed", personSalary)

}

==6b ..................................==========
==ex1-typed.go========================
package main

import "fmt"

func main() {

	var a = "aaa" //string

	type myString string
	var b myString = "bbb" //myString

	//b = a		//not allowed because type does not matched (string, myStrin)

	//Re-assigning : allowed
    //a = "a1"
	//b = "b1"

	fmt.Printf("%v %T ", a, a)	//aaa string

	fmt.Printf("%v %T ", b, b)	//bbb main.myString
	
	c := 'u' //char 
	fmt.Printf("%v %T ", c, c)	//117 int32
}

==ex2-str-to-byte.go========================
package main

import (  
    "fmt"
)

func printBytes(s string) {  
    for i:= 0; i < len(s); i++ {
        fmt.Printf("%x ", s[i])
    }
}

func main() {  
    name := "Hello World"
    printBytes(name)
}
==ex3-str-to-byte-char.go========================
package main

import (  
    "fmt"
)

func printBytes(s string) {  
    for i:= 0; i < len(s); i++ {
        fmt.Printf("%x ", s[i])
    }
}


func printChars(s string) {  
    for i:= 0; i < len(s); i++ {
        fmt.Printf("%c ",s[i])
    }
}

func main() {  
    name := "Hello World"
    printBytes(name)
    fmt.Printf("\n")
    printChars(name)
}
==ex4-byte-rune.go========================
package main

import (  
    "fmt"
)

func printBytes(s string) {  
    for i:= 0; i < len(s); i++ {
        fmt.Printf("%x ", s[i])
    }
}

func printChars(s string) {  
    for i:= 0; i < len(s); i++ {
        fmt.Printf("%c ",s[i])
    }
}

func printCharsByte(s string) { 
    bytes := []byte(s)
    for i:= 0; i < len(bytes); i++ {
        fmt.Printf("%c ",bytes[i])
    }
}

func printCharsRune(s string) {  
    runes := []rune(s)
    for i:= 0; i < len(runes); i++ {
        fmt.Printf("%c ",runes[i])
    }
}

func main() {  	
    name := "Señor"
	
    printBytes(name) ; 		fmt.Println()			
	printChars(name) ;		fmt.Println()	
    printCharsByte(name) ;	fmt.Println()	
    printCharsRune(name)		
}







==ex5-range.go========================
package main

import (  
    "fmt"
)

func printCharsAndBytes(s string) {  
    for index, rune := range s {
        fmt.Printf("Index %d, Char %c, Hex %x \n", index, rune, rune )
    }
}

func main() {  
    name := "Señor"
    printCharsAndBytes(name)
}
==ex6-byte-rune.go========================
package main

import (  
    "fmt"
)

func main() {

byte_hex()
byte_dec()
runes()

}

func byte_hex() {  
    byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9}
    str := string(byteSlice)
    fmt.Println(str)	//Café
}

func byte_dec() {  
    byteSlice := []byte{67, 97, 102, 195, 169}//decimal equivalent of {'\x43', '\x61', '\x66', '\xC3', '\xA9'}
    str := string(byteSlice)
    fmt.Println(str)	//Café
}

func runes() {  //hexadecimal
    runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
    str := string(runeSlice)
    fmt.Println(str)	//Señor
}
==ex7-string-length.go========================
package main

import (
	"fmt"
	"unicode/utf8"
)

func length(s string) {
	fmt.Println(utf8.RuneCountInString(s))
}
func main() {

	word1 := "Señor"
	length(word1)  				//5
	fmt.Println(len(word1)) 	//6

	fmt.Println("========")

	word2 := "Pets"
	length(word2)				//4
	fmt.Println(len(word2))		//4
}

==ex8-immutable-mutate.go========================
package main

import (  
    "fmt"
)

/*
func mutate(s string)string {  
    s[0] = 'a'//any valid unicode character within single quote is a rune 
    return s
}

func main() {  
    h := "hello"
    fmt.Println(mutate(h))
}
*/


func mutate(s []rune) string {  
    s[0] = 'a' 
    return string(s)
}
func main() {  
    h := "hello"
    fmt.Println(mutate([]rune(h)))
}



==7a ..................................==========
==7-pointer.go========================
package main

import (  
    "fmt"
)

func main() {
		pointer()
		pointer_nil()
		pointer_new()
		pointer_dereferencing()
		pointer_dereferencing1()
		function_passing_pointer()
		function_returning_pointer()
		function_passing_array()
		function_passing_slices()
		pointer_arithmetic()
		
}
//*T is the type of the pointer variable which points to a value of type T. 
func pointer() {  
    b := 255
    var a *int = &b
    fmt.Printf("Type of a is %T\n", a)
    fmt.Println("address of b is", a)
	fmt.Println("a = ", *a)
}

func pointer_nil() {  
    a := 25
    var b *int
    if b == nil {
        fmt.Println("b is", b)
        b = &a
        fmt.Println("b after initialization is", b)
		fmt.Println("b = ", *b)
    }
}

//Creating pointers using the new function
func pointer_new() {  
    size := new(int)
    fmt.Printf("Size value is %d, type is %T, address is %v\n", *size, size, size)
    *size = 85
    fmt.Println("New size value is", *size)
}

func pointer_dereferencing() {   
    b := 150
    a := &b
    fmt.Println("address of b is", a)
    fmt.Println("value of b is", *a)
}

func pointer_dereferencing1() {  
    b := 255
    a := &b
	fmt.Println()
    fmt.Println("address of b is", a)
    fmt.Println("value of b is", *a)
    *a++
    fmt.Println("new value of b is", b)
}

func pointer_change(c *int) {  
    *c = 55
}
func function_passing_pointer() {  
    a := 58
    fmt.Println("a = ",a)
    b := &a
    pointer_change(b)
    fmt.Println("a = ", a)
}

func pointer_hello() *int {  
    i := 15
    return &i
}
func function_returning_pointer() {  
	fmt.Println()
    d := pointer_hello()
    fmt.Println("d = ", *d)
}

/*Do not pass a pointer to an array as a argument to a function. Use slice instead.*/
func pointer_modify_array(arr *[3]int) {  
    (*arr)[0] = 90
	//arr[0] = 90	//also working
}

func function_passing_array() {  
    a := [3]int{89, 90, 91}
    pointer_modify_array(&a)
    fmt.Println("by array", a)
}

/*Although this way of passing a pointer to an array as a argument to a function and making modification is working but, 
it is not the idiomatic way. In Go slices is used to achieve this.
*/
func pointer_modify_slices(sls []int) {  
    sls[0] = 90
}
func function_passing_slices() {  
    a := [3]int{89, 90, 91}
    pointer_modify_slices(a[:])
    fmt.Println("by slice",a)
}

/*Go does not support pointer arithmetic which is present in other languages like C and C++.*/
func pointer_arithmetic() {  
    b := [...]int{109, 110, 111}
    p := &b

    //p++	//arithmetic calcultion is not allowed over pointer

	fmt.Println(b)
	fmt.Println(p)
	fmt.Println(*p)
}



==7b ..................................==========
==ex1-named-struct.go========================
package main

import (  
    "fmt"
)

type Employee struct {  
    firstName, lastName string
    age, salary         int
}

func main() {

    //creating structure using field names
    emp1 := Employee{
        firstName: "aa",
        age:       25,
        salary:    500,
        lastName:  "aaa",
    }

    //creating structure without using field names
    emp2 := Employee{"bb", "bbb", 29, 800}

    fmt.Println("Employee 1", emp1)	//Employee 1 {Sam Anderson 25 500}
    fmt.Println("Employee 2", emp2) //Employee 2 {Thomas Paul 29 800}

}
==ex10-structs-equality.go========================
/*
Struct variables are not comparable if they contain fields which are not comparable 

main.go:18: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared).
*/

package main

import (  
    "fmt"
)

type image struct {  
    data map[int]int
}

func main() {  
    image1 := image{data: map[int]int{
        0: 155,
    }}
    image2 := image{data: map[int]int{
        0: 155,
    }}
    if image1 == image2 {
        fmt.Println("image1 and image2 are equal")
    }
}
==ex2-anonymous-struct.go========================
package main

import (  
    "fmt"
)

func main() {  
    emp3 := struct {
        firstName, lastName string
        age, salary         int
    }{
        firstName: "Andreah",
        lastName:  "Nikola",
        age:       31,
        salary:    5000,
    }

    fmt.Println("Employee 3", emp3)
}
==ex3-zero-value-struct.go========================
package main

import (  
    "fmt"
)

type Employee struct {  
    firstName, lastName string
    age, salary         int
}

func main() {  
    var emp4 Employee //zero valued structure
    fmt.Println("Employee 4", emp4)
}
==ex4.go========================
package main

import (  
    "fmt"
)

type Employee struct {  
    firstName, lastName string
    age, salary         int
}


func main1() {  
    emp := Employee{
        firstName: "aa",
        lastName:  "aaa",
    }
    fmt.Println("Employee", emp)	//Employee 5 {John Paul 0 0}
}

func main2() {  
    emp6 := Employee{"bb", "bbb", 55, 6000}
    fmt.Println("First Name:", emp6.firstName)
    fmt.Println("Last Name:", emp6.lastName)
    fmt.Println("Age:", emp6.age)
    fmt.Printf("Salary: $%d", emp6.salary)
}

func main() {  
    var emp7 Employee
    emp7.firstName = "cc"
    emp7.lastName = "ccc"
    fmt.Println("Employee 7:", emp7) //Employee 7: {Jack Adams 0 0}
}
==ex5-pointer.go========================
package main

import (  
    "fmt"
)

type Employee struct {  
    firstName, lastName string
    age, salary         int
}

func main() {  
    emp8 := &Employee{"aa", "xx", 20, 2000}
    fmt.Println("First Name:", (*emp8).firstName) 
    fmt.Println("Age:", (*emp8).age)
	
    fmt.Println("First Name:", emp8.firstName)	//also allowed
    fmt.Println("Age:", emp8.age)				//also allowed
	
    emp81 := Employee{"bb", "xx", 40, 4000}	
    fmt.Println("First Name:", (emp81).firstName)
    fmt.Println("Age:", (emp81).age)	
}
==ex6-anonymous-field.go========================
package main

import (
	"fmt"
)

type Person struct {
	string
	int
}

func main() {
	main1()
	main2()
}

///////////////
func main1() {
	p := Person{"aa", 50}
	fmt.Println(p) //{aa 50}

	//not allowed - not in proper sequence
	//q := Person{ 40,"bb" }
	//fmt.Println(q)
}

func main2() {
	var p1 Person
	p1.string = "cc"
	p1.int = 20
	fmt.Println(p1) //{cc 20}
}

==ex7-nested.go========================
package main

import (  
    "fmt"
)

type Address struct {  
    city, state string
}
type Person struct {  
    name string
    age int
    address Address
}

func main() {  
    var p Person
    p.name = "aa"
    p.age = 20
    p.address = Address {
        city: "New Delhi",
        state: "Delhi",
    }
    fmt.Println("Name:", p.name)
    fmt.Println("Age:",p.age)
    fmt.Println("City:",p.address.city)
    fmt.Println("State:",p.address.state)
}
==ex8-promoted.go========================
package main

import (  
    "fmt"
)

type Address struct {  
    city, state string
}
type Person struct {  
    name string
    age int
    Address
}

func main() {  
    var p Person
    p.name = "aa"
    p.age = 20
    p.Address = Address{
        city:  "Chicago",
        state: "Illinois",
    }
    fmt.Println("Name:", p.name)
    fmt.Println("Age:", p.age)
    fmt.Println("City:", p.city) //city is promoted field
    fmt.Println("State:", p.state) //state is promoted field
}

==ex9-structs-equality.go========================
package main

import (  
    "fmt"
)

type name struct {  
    firstName string
    lastName string
}


func main() {  
    name1 := name{"aa", "xx"}
    name2 := name{"aa", "xx"}
    if name1 == name2 {
        fmt.Println("name1 and name2 are equal")
    } else {
        fmt.Println("name1 and name2 are not equal")
    }

    name3 := name{firstName:"bb", lastName:"yy"}
    name4 := name{}
    name4.firstName = "bb"
	//name4.lastName = "yy"
    if name3 == name4 {
        fmt.Println("name3 and name4 are equal")
    } else {
        fmt.Println("name3 and name4 are not equal")
    }
}

==7c ..................................==========
==main.go========================
package main

import "golangbot2/7-methods/mymethod"
 
func main() {  

mymethod.Method_basic()
mymethod.Method_overloading()
mymethod.Method_anonymous_fields()
mymethod.Method_and_type();

mymethod.Method_pointer_receiver()
mymethod.Method_pointer_receiver_ex1()
mymethod.Method_pointer_receiver_ex2()

}
==method-basic.go========================
package mymethod

import (  
    "fmt"
)

type Employee struct {  
    name     string
    salary   int
    currency string
}

//method
func (e Employee) displaySalary() {  
    fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
}

//function
func displaySalary1(e Employee) {  
    fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
}

func Method_basic() { 
    fmt.Println("\n+++  method_basic  +++++")	  
    emp1 := Employee {
        name:     "Ram Singh",
        salary:   5000,
        currency: "$",
    }
    emp1.displaySalary() //method calling
	fmt.Println()
    displaySalary1(emp1) //function calling
}

/*
Go is not a pure object oriented programming language and it does not support classes. 
Hence methods on types is a way to achieve behaviour similar to classes.

Methods with same name can be defined on different types whereas functions with the same names are not allowed. 

*/

==method_and_type.go========================
/*
To define a method on a type, the definition of the receiver type of the method and the definition of the method should be in the same package. 
So far, all the structs and the methods on structs we defined where all located in the same main package and hence they worked.

This method is not linked with structure
cannot define new methods on non-local type int
It cannot be compiled 

package main


func (a int) add(b int) {  
}

func method_and_type() {

}
*/
///////////////////////////////////////////////

//The way to get this working is to create a type alias for the built-in type int and then create a method with this type alias as the receiver.


package mymethod

import "fmt"

type myInt int

func (a myInt) add(b myInt) myInt {  
    return a + b
}

func Method_and_type() {  

	fmt.Println("\n+++  method_and_type  +++++")	
	
    num1 := myInt(5)
    num2 := myInt(10)
    sum := num1.add(num2)
    fmt.Println("Sum is", sum)
}

==method_anonymous_fields.go========================
package mymethod

import (  
    "fmt"
)

type address struct {  
    city  string
    state string
}

func (a address) fullAddress() {  
    fmt.Printf("Full address: %s, %s", a.city, a.state)
}

type person struct {  
    firstName string
    lastName  string
    address
}

func Method_anonymous_fields() {  
	fmt.Println("\n+++  method_anonymous_fields  +++++")	 
    p := person{
        firstName: "Ram",
        lastName:  "Singh",
        address: address {
            city:  "New Delhi",
            state: "Delhi",
        },
    }

    p.fullAddress() //accessing fullAddress method of address struct
	fmt.Println()
    fmt.Println(p.firstName, p.address.city, p.city)

}
==method_overloading.go========================
package mymethod

import (  
    "fmt"
    "math"
)

type Rectangle struct {  
    length int
    width  int
}

type Circle struct {  
    radius float64
}

func (r Rectangle) Area() int {  
    return r.length * r.width
}

func (c Circle) Area() float64 {  
    return math.Pi * c.radius * c.radius
}

func Method_overloading() { 
	fmt.Println("\n+++  method_overloading  +++++")	   
    r := Rectangle{
        length: 10,
        width:  5,
    }
    fmt.Printf("Area of rectangle %d\n", r.Area())
    c := Circle{
        radius: 12,
    }
    fmt.Printf("Area of circle %f", c.Area())
}

==method_pointer_sender_receiver.go========================
/*Value receivers in methods vs value arguments in functions

func:: sender:value - receiver:value
func:: sender:ref - receiver:pointer

func:: sender:value - receiver:pointer  X - not allowed
func:: sender:ref - receiver:value      X - not allowed

method:: sender:value/ref - receiver:value
method:: sender:value/ref - receiver:pointer

*/

package mymethod
import "fmt"

type rectangle struct {  
    length int
    width  int
}

//Receiver Function===========================

func area(r rectangle) {  
    fmt.Printf("Area - Function (sender:value, receive: value): %d\n", (r.length * r.width))
}

func area_func_pointer(r *rectangle) {  
  fmt.Printf("Area - Function (sender:ref, receive: pointer): %d\n", (r.length * r.width))
}

//Receiver Method==========================
func (r rectangle) area() {  
    fmt.Printf("Area + Method (sender:value/ref, receive: value): %d\n", (r.length * r.width))
}

func (r *rectangle) area_method_pointer() {  
    fmt.Printf("Area + Method (sender:value/ref, receive: pointer): %d\n", (r.length * r.width))
}

func Method_pointer_receiver() {  
	fmt.Println("\n+++  method_pointer_receiver  +++++")
    r := rectangle{
        length: 10,
        width:  5,
    }
    p := &r  

    //func:: sender:value - receiver:value====================================================
    area(r)      //area(*p), function call by value  
    //area(&r)   //area(p), function call by reference - not allowed

	//func:: sender:ref - receiver:pointer
    //area_func_pointer(r) //function call by value - not allowed
    area_func_pointer(p)   //function call by reference  
 
    fmt.Println("+++  ---------  +++++")
   
    //method:: sender:value/ref - receiver:value===================================================
    r.area()     //method call by value 
    (*p).area()

    p.area()    //method call by reference 
    (&r).area()

    fmt.Println("+++  ---------  +++++")
     
   //method:: sender:value/ref - receiver:pointer
    r.area_method_pointer()     //method call by value 
    (*p).area_method_pointer()

    p.area_method_pointer()    //method call by reference 
    (&r).area_method_pointer()
    
}

==method_pointer_sender_receiver_ex1.go========================
/*Pointer receivers vs value receivers*/
package mymethod

import (  
    "fmt"
)

type rectangle1 struct {  
    length int
    width  int
}

func perimeter(r *rectangle1) {   //function - pointer receiving (val not allowed)
    fmt.Println("perimeter function output:", 2*(r.length+r.width))

}

func (r *rectangle1) perimeter() {  //method - pointer receiving (val can be allowed)
    fmt.Println("perimeter method output:", 2*(r.length+r.width))
}

func Method_pointer_receiver_ex1() { 
 
	fmt.Println("\n+++  method_pointer_receiver_ex1  +++++")	 
	//r-value, p-pointer
    r := rectangle1{
        length: 10,
        width:  5,
    }
    p := &r 
	
    perimeter(p)		//function - ref	- allowed
    //perimeter(r)		//function - val	- not allowed 
	
    p.perimeter()		//method - ref		- allowed
    r.perimeter()		//method - val		- allowed

}
==method_pointer_sender_receiver_ex2.go========================
/*Pointer receivers vs value receivers*/
package mymethod

import (  
    "fmt"
)

type Employee1 struct {  
    name string
    age  int
}

//value receiver  - temp changes
func (e Employee1) changeName(newName string) {  
    e.name = newName
	fmt.Println(e)
}

//pointer receiver - fixed changes
func (e *Employee1) changeAge(newAge int) {  
    e.age = newAge
	fmt.Println(e)
}

func Method_pointer_receiver_ex2() {  
	e := Employee1{
		name: "Ram",
		age:  50,
	}
	fmt.Println("\n+++  method_pointer_receiver_ex2  +++++")	 

	fmt.Printf(e.name) //Ram
	e.changeName("Shyam") //no impact 
	fmt.Printf(e.name) //Ram

	fmt.Printf("\nage: %d", e.age) //50 - before change
	(&e).changeAge(30) //method calling (by pointer)
	//e.changeAge(30)      //method calling  
	fmt.Printf("\nage: %d", e.age) //30 - after change
	
	//debug
	fmt.Println(e)
}


==8 ..................................==========
==ex1-basic.go========================
package main

import (  
    "fmt"
)

//interface definition
type VowelsFinder interface {  
    FindVowels() []rune
}

type MyString string

//MyString implements VowelsFinder
func (ms MyString) FindVowels() []rune {  
    var vowels []rune
    for _, rune1 := range ms {
        if rune1 == 'a' || rune1 == 'e' || rune1 == 'i' || rune1 == 'o' || rune1 == 'u' {
            vowels = append(vowels, rune1)
        }
    }
    return vowels
}

func main() {  
    name := MyString("Sam Anderson")
    var v VowelsFinder
    v = name // possible since MyString implements VowelsFinder
    fmt.Printf("Vowels are %c", v.FindVowels())

}
==ex2-salary.go========================
package main

import (  
    "fmt"
)

type SalaryCalculator interface {  
    CalculateSalary() int
}

type Permanent struct {  
    empId    int
    basicpay int
    pf       int
}

type Contract struct {  
    empId  int
    basicpay int
}

//salary of permanent employee is sum of basic pay and pf
func (p Permanent) CalculateSalary() int {  
    return p.basicpay + p.pf
}

//salary of contract employee is the basic pay alone
func (c Contract) CalculateSalary() int {  
    return c.basicpay
}

/*
total expense is calculated by iterating though the SalaryCalculator slice and summing  
the salaries of the individual employees  
*/
func totalExpense(s []SalaryCalculator) {  
    expense := 0
    for _, v := range s {
        expense = expense + v.CalculateSalary()
    }
    fmt.Printf("Total Expense Per Month $%d", expense)
}

func main() {  
    pemp1 := Permanent{1, 5000, 20}
    pemp2 := Permanent{2, 6000, 30}
    cemp1 := Contract{3, 3000}
    employees := []SalaryCalculator{pemp1, pemp2, cemp1}
    totalExpense(employees)

}
==ex3-type-value.go========================
package main

import (  
    "fmt"
)

type Tester interface {  
    Test()
}

type MyFloat float64

func (m MyFloat) Test() {  
    fmt.Println(m)
}

func describe(t Tester) {  
    fmt.Printf("Interface type %T value %v\n", t, t)
}

func main() {  
    var t Tester
    f := MyFloat(89.7)
    t = f
    describe(t)
    t.Test()
}
==ex4-empty.go========================
package main

import (  
    "fmt"
)

func describe(i interface{}) {  
    fmt.Printf("Type = %T, value = %v\n", i, i)
}

func main() {  
    s := "Hello World"
    describe(s)
    i := 55
    describe(i)
    strt := struct {
        name string
    }{
        name: "Naveen R",
    }
    describe(strt)
}
==ex5-assert.go========================
package main

import (  
    "fmt"
)

func assert(i interface{}) {  
    s := i.(int) //get the underlying int value from i
    fmt.Println(s)
}
func main() {  
    var s interface{} = 56
    assert(s)
}
==ex6-assert.go========================
package main

import (  
    "fmt"
)

func assert(i interface{}) {  
    s := i.(int) //error 
	//s := i.(string) 
    fmt.Println(s)
}
func main() {  
    var s interface{} = "aa bb"
    assert(s)
}
==ex7-assert.go========================
package main

import (  
    "fmt"
)

func assert(i interface{}) {  
    v, ok := i.(int)
    fmt.Println(v, ok)
}
func main() {  
    var s interface{} = 56
    assert(s)
    var i interface{} = "Steven Paul"
    assert(i)
}
==ex8-switch.go========================
package main

import (  
    "fmt"
)

func findType(i interface{}) {  
    switch i.(type) {
    case string:
        fmt.Printf("I am a string and my value is %s\n", i.(string))
    case int:
        fmt.Printf("I am an int and my value is %d\n", i.(int))
    default:
        fmt.Printf("Unknown type\n")
    }
}
func main() {  
    findType("Naveen")
    findType(77)
    findType(89.98)
}
==ex9-compare.go========================
package main

import "fmt"

type Describer interface {  
    Describe()
}
type Person struct {  
    name string
    age  int
}

func (p Person) Describe() {  
    fmt.Printf("%s is %d years old", p.name, p.age)
}

func findType(i interface{}) {  
    switch v := i.(type) {
    case Describer:
        v.Describe()
    default:
        fmt.Printf("unknown type\n")
    }
}

func main() {  
    findType("Naveen")
    p := Person{
        name: "Naveen R",
        age:  25,
    }
    findType(p)
}
==readme.txt========================
package main 
  
import "fmt"
  
 
func main() { 
  
    var val1 interface{} = 6.5
    var val2 interface{} = "aa"      
      
    fmt.Println("Value: ", val1.(float32)) 
    fmt.Println("Value: ", val2.(string)) 
} 

==8a ..................................==========
==ex1-value-pointer.go========================
package main

import "fmt"

type Describer interface {  
    Describe()
}
type Person struct {  
    name string
    age  int
}

func (p Person) Describe() { //implemented using value receiver  
    fmt.Printf("%s is %d years old\n", p.name, p.age)
}

type Address struct {  
    state   string
    country string
}

func (a *Address) Describe() { //implemented using pointer receiver  
    fmt.Printf("State %s Country %s", a.state, a.country)
}

func main() {  
    var d1 Describer
    p1 := Person{"Sam", 25}
    d1 = p1
    d1.Describe()
    p2 := Person{"James", 32}
    d1 = &p2
    d1.Describe()

    var d2 Describer
    a := Address{"Washington", "USA"}

    /* compilation error if the following line is
       uncommented
       cannot use a (type Address) as type Describer
       in assignment: Address does not implement
       Describer (Describe method has pointer
       receiver)
    */
    //d2 = a

    d2 = &a //This works since Describer interface
    //is implemented by Address pointer in line 22
    d2.Describe()

}
==ex2-multiple.go========================
package main

import (  
    "fmt"
)

type SalaryCalculator interface {  
    DisplaySalary()
}

type LeaveCalculator interface {  
    CalculateLeavesLeft() int
}

type Employee struct {  
    firstName string
    lastName string
    basicPay int
    pf int
    totalLeaves int
    leavesTaken int
}

func (e Employee) DisplaySalary() {  
    fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
}

func (e Employee) CalculateLeavesLeft() int {  
    return e.totalLeaves - e.leavesTaken
}

func main() {  
    e := Employee {
        firstName: "Naveen",
        lastName: "Ramanathan",
        basicPay: 5000,
        pf: 200,
        totalLeaves: 30,
        leavesTaken: 5,
    }
    var s SalaryCalculator = e
    s.DisplaySalary()
    var l LeaveCalculator = e
    fmt.Println("\nLeaves left =", l.CalculateLeavesLeft())
}

==ex3-embedded.go========================
package main

import (  
    "fmt"
)

type SalaryCalculator interface {  
    DisplaySalary()
}

type LeaveCalculator interface {  
    CalculateLeavesLeft() int
}

type EmployeeOperations interface {  
    SalaryCalculator
    LeaveCalculator
}

type Employee struct {  
    firstName string
    lastName string
    basicPay int
    pf int
    totalLeaves int
    leavesTaken int
}

func (e Employee) DisplaySalary() {  
    fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
}

func (e Employee) CalculateLeavesLeft() int {  
    return e.totalLeaves - e.leavesTaken
}

func main() {  
    e := Employee {
        firstName: "Naveen",
        lastName: "Ramanathan",
        basicPay: 5000,
        pf: 200,
        totalLeaves: 30,
        leavesTaken: 5,
    }
    var empOp EmployeeOperations = e
    empOp.DisplaySalary()
    fmt.Println("\nLeaves left =", empOp.CalculateLeavesLeft())
}
==ex4-zero.go========================
package main

import "fmt"

type Describer interface {  
    Describe()
}

func main() {  
    var d1 Describer
    if d1 == nil {
        fmt.Printf("d1 is nil and has type %T value %v\n", d1, d1)
    }
}
==ex5-zero-panic.go========================
package main

type Describer interface {  
    Describe()
}

func main() {  
    var d1 Describer
    d1.Describe()
}


/*
panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xc0000005 code=0x0 addr=0x0 pc=0x455a46]

*/


==9 ..................................==========
==ex1.go========================
/*
    -When a new Goroutine is started, the goroutine call returns immediately. Unlike functions, the control does not wait for the Goroutine to finish executing. The control returns immediately to the next line of code after the Goroutine call and any return values from the Goroutine are ignored.
	
    -The main Goroutine should be running for any other Goroutines to run. If the main Goroutine terminates then the program will be terminated and no other Goroutine will run.
*/

/*
package main

import (  
    "fmt"
)

func hello() {  
    fmt.Println("Hello world goroutine")
}
func main() {  
    go hello()
    fmt.Println("main function")
}
*/


package main

import (  
    "fmt"
    "time"
)

func hello() {  
    fmt.Println("Hello world goroutine")
}
func main() {  
    go hello()
    time.Sleep(1 * time.Second)
    fmt.Println("main function")
}
==ex2-multiple.go========================
package main

import (  
    "fmt"
    "time"
)

func numbers() {  
    for i := 1; i <= 5; i++ {
        time.Sleep(250 * time.Millisecond)
        fmt.Printf("%d ", i)
    }
}
func alphabets() {  
    for i := 'a'; i <= 'e'; i++ {
        time.Sleep(400 * time.Millisecond)
        fmt.Printf("%c ", i)
    }
}
func main() {  
    go numbers()
    go alphabets()
    time.Sleep(3000 * time.Millisecond)
	
    fmt.Println("\nmain terminated")
}
==ex3.go========================
package main

import (
	"fmt"
)

func f(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {
	f("F - 1")
	go f("GR - 2")

	//inline function
	go func() {
		fmt.Println("GR - 3")
	}() //func calling

	go func(msg string) {
		fmt.Println(msg)
	}("GR - 4") //func calling and params passing

	a := func(msg string) {
		fmt.Println(msg)
	}
	a("GR - 5") //func calling and params passing

	fmt.Scanln()
	fmt.Println("Finish - 6")
}


==910 ..................................==========
==1 -- basic========================
==ex-1-channel-declaration.go========================
package main

import "fmt"

func main() {  
    var a chan int
    if a == nil {
        fmt.Println("channel a is nil, going to define it")
        a = make(chan int)
        fmt.Printf("Type of a is %T", a)
    }
}
==ex-2.go========================
/*

data := <- a // read from channel a  
a <- data // write to channel a  


Sends and receives are blocking by default
Sends and receives to a channel are blocking by default. What does this mean? When a data is sent to a channel, the control is blocked in the send statement until some other Goroutine reads from that channel. Similarly when data is read from a channel, the read is blocked until some Goroutine writes data to that channel.

This property of channels is what helps Goroutines communicate effectively without the use of explicit locks or conditional variables that are quite common in other programming languages.

*/


//goroutine with sleep

/*
package main

import (  
    "fmt"
    "time"
)

func hello() {  
    fmt.Println("Hello world goroutine")
}
func main() {  
    go hello()
    time.Sleep(1 * time.Second)
    fmt.Println("main function")
}

*/

//goroutine with channel
package main

import (  
    "fmt"
)

func hello(done chan bool) {  
    fmt.Println("Hello world goroutine")
    done <- true
}
func main() {  
    done := make(chan bool)
    go hello(done)
    <-done
    fmt.Println("main function")
}


==ex-21.go========================
package main

import (  
    "fmt"
    "time"
)

func hello(done chan bool) {  
    fmt.Println("hello go routine is going to sleep")
    time.Sleep(4 * time.Second)
    fmt.Println("hello go routine awake and going to write to done")
    done <- true
}
func main() {  
    done := make(chan bool)
    fmt.Println("Main going to call hello go goroutine")
    go hello(done)
    <-done
    fmt.Println("Main received data")
}
==ex-22.go========================
package main

import (  
    "fmt"
)

func calcSquares(number int, squareop chan int) {  
    sum := 0
    for number != 0 {
        digit := number % 10
        sum += digit * digit
        number /= 10
    }
    squareop <- sum
}

func calcCubes(number int, cubeop chan int) {  
    sum := 0 
    for number != 0 {
        digit := number % 10
        sum += digit * digit * digit
        number /= 10
    }
    cubeop <- sum
} 

func main() {  
    number := 589
    sqrch := make(chan int)
    cubech := make(chan int)
    go calcSquares(number, sqrch)
    go calcCubes(number, cubech)
    squares, cubes := <-sqrch, <-cubech
    fmt.Println("Final output", squares + cubes)
}

==ex-3-deadlock.go========================
package main

import (  
    "fmt"
)


func main() {  
    ch := make(chan int, 1)
    ch <- 5
	
	 fmt.Println(<- ch)
}
==ex4-unidirectional.go========================
/*
data := <- a // read from channel a  
a <- data // write to channel a  

All the channels we discussed so far are bidirectional channels, that is data can be both sent and received on them. It is also possible to create unidirectional channels, that is channels that only send or receive data.
*/

package main

import "fmt"

func sendData(sendch chan<- int) {  
    sendch <- 10
}

func main() {  
    chnl := make(chan int)
    go sendData(chnl)
    fmt.Println(<-chnl)
}
==ex5-for.go========================
package main

import (  
    "fmt"
)

func producer(chnl chan int) {  
    for i := 0; i < 10; i++ {
        chnl <- i
    }
    close(chnl)
}
func main() {  
    ch := make(chan int)
    go producer(ch)
    for {
        v, ok := <-ch
        if ok == false {
            break
        }
        fmt.Println("Received ", v, ok)
    }
}
==ex6-range.go========================
package main

import (  
    "fmt"
)

func producer(chnl chan int) {  
    for i := 0; i < 10; i++ {
        chnl <- i
    }
    close(chnl)
}
func main() {  
    ch := make(chan int)
    go producer(ch)
    for v := range ch {
        fmt.Println("Received ",v)
    }
}
==ex7.go========================
package main

import (
	"fmt"
)

func digits(number int, dchnl chan int) {
	for number != 0 {
		digit := number % 10
		dchnl <- digit
		number /= 10
	}
	close(dchnl)
}
func calcSquares(number int, squareop chan int) {
	sum := 0
	dch := make(chan int)
	go digits(number, dch)
	for digit := range dch {
		sum += digit * digit
	}
	squareop <- sum
}

func calcCubes(number int, cubeop chan int) {
	sum := 0
	dch := make(chan int)
	go digits(number, dch)
	for digit := range dch {
		sum += digit * digit * digit
	}
	cubeop <- sum
}

func main() {
	number := 123 // 1-4-9 + 1-8-27
	sqrch := make(chan int)
	cubech := make(chan int)
	go calcSquares(number, sqrch)
	go calcCubes(number, cubech)
	squares, cubes := <-sqrch, <-cubech
	fmt.Println("Final output", squares+cubes)
}


==2 -- buffered========================
==ex1.go========================
package main

import (  
    "fmt"
)


func main() {  
    ch := make(chan string, 2)
    ch <- "naveen"
    ch <- "paul"
    fmt.Println(<- ch)
    fmt.Println(<- ch)
}
==ex2.go========================
package main

import (  
    "fmt"
    "time"
)

func write(ch chan int) {  
    for i := 0; i < 5; i++ {
        ch <- i
        fmt.Println("successfully wrote", i, "to ch")
    }
    close(ch)
}
func main() {  
    ch := make(chan int, 2)
    go write(ch)
    time.Sleep(2 * time.Second)
    for v := range ch {
        fmt.Println("read value", v,"from ch")
        time.Sleep(2 * time.Second)

    }
}
==ex3-deadlock.go========================
package main

import (  
    "fmt"
)

func main() {  
    ch := make(chan string, 2)
    ch <- "naveen"
    ch <- "paul"
    ch <- "steve"
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
==ex4-capacity-length.go========================
//The capacity of a buffered channel is the number of values that the channel can hold. This is the value we specify when creating the buffered channel using the make function.
//The length of the buffered channel is the number of elements currently queued in it.


package main

import (  
    "fmt"
)

func main() {  
    ch := make(chan string, 3)
    ch <- "manoj"
    ch <- "kumar"
    fmt.Println("capacity is", cap(ch))
    fmt.Println("length is", len(ch))
    fmt.Println("read value", <-ch)
    fmt.Println("new length is", len(ch))
}
==ex5-wait-group.go========================
/*
WaitGroup
The next section in this tutorial is about Worker Pools. To understand worker pools, we need to first know about WaitGroup as it will be used in the implementation of Worker pool.

A WaitGroup is used to wait for a collection of Goroutines to finish executing. The control is blocked until all Goroutines finish executing. Lets say we have 3 concurrently executing Goroutines spawned from the main Goroutine. The main Goroutines needs to wait for the 3 other Goroutines to finish before terminating. This can be accomplished using WaitGroup.

*/

package main

import (  
    "fmt"
    "sync"
    "time"
)

func process(i int, wg *sync.WaitGroup) {  
    fmt.Println("started Goroutine ", i)
    time.Sleep(2 * time.Second)
    fmt.Printf("Goroutine %d ended\n", i)
    wg.Done()
}

func main() {  
    no := 3
    var wg sync.WaitGroup
    for i := 0; i < no; i++ {
        wg.Add(1)
        go process(i, &wg)
    }
    wg.Wait()
    fmt.Println("All go routines finished executing")
}
==ex6-worker-pool.go========================
package main

import (  
    "fmt"
    "math/rand"
    "sync"
    "time"
)

type Job struct {  
    id       int
    randomno int
}
type Result struct {  
    job         Job
    sumofdigits int
}

var jobs = make(chan Job, 10)  
var results = make(chan Result, 10)

func digits(number int) int {  
    sum := 0
    no := number
    for no != 0 {
        digit := no % 10
        sum += digit
        no /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}
func worker(wg *sync.WaitGroup) {  
    for job := range jobs {
        output := Result{job, digits(job.randomno)}
        results <- output
    }
    wg.Done()
}
func createWorkerPool(noOfWorkers int) {  
    var wg sync.WaitGroup
    for i := 0; i < noOfWorkers; i++ {
        wg.Add(1)
        go worker(&wg)
    }
    wg.Wait()
    close(results)
}
func allocate(noOfJobs int) {  
    for i := 0; i < noOfJobs; i++ {
        randomno := rand.Intn(999)
        job := Job{i, randomno}
        jobs <- job
    }
    close(jobs)
}
func result(done chan bool) {  
    for result := range results {
        fmt.Printf("Job id %d, input random no %d , sum of digits %d\n", result.job.id, result.job.randomno, result.sumofdigits)
    }
    done <- true
}
func main() {  
    startTime := time.Now()
    noOfJobs := 100
    go allocate(noOfJobs)
    done := make(chan bool)
    go result(done)
    noOfWorkers := 10
    createWorkerPool(noOfWorkers)
    <-done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println("total time taken ", diff.Seconds(), "seconds")
}
==readme.txt========================
What are buffered channels?
All the channels we discussed in the previous tutorial were basically unbuffered. As we discussed in the channels tutorial in detail, sends and receives to an unbuffered channel are blocking.

It is possible to create a channel with a buffer. Sends to a buffered channel are blocked only when the buffer is full. Similarly receives from a buffered channel are blocked only when the buffer is empty.

Buffered channels can be created by passing an additional capacity parameter to the make function which specifies the size of the buffer.

ch := make(chan type, capacity)  
capacity in the above syntax should be greater than 0 for a channel to have a buffer. The capacity for an unbuffered channel is 0 by default and hence we omitted the capacity parameter while creating channels in the previous tutorial.

Lets write some code and create a buffered channel.

==3 -- select========================
==ex1.go========================
package main

import (  
    "fmt"
    "time"
)

func server1(ch chan string) {  
    time.Sleep(6 * time.Second)
    ch <- "from server1"
}
func server2(ch chan string) {  
    time.Sleep(3 * time.Second)
    ch <- "from server2"

}
func main() {  
    output1 := make(chan string)
    output2 := make(chan string)
    go server1(output1)
    go server2(output2)
    select {
    case s1 := <-output1:
        fmt.Println(s1)
    case s2 := <-output2:
        fmt.Println(s2)
    }
}
==ex2.go========================
package main

import (  
    "fmt"
    "time"
)

func process(ch chan string) {  
    time.Sleep(10500 * time.Millisecond)
    ch <- "process successful"
}

func main() {  
    ch := make(chan string)
    go process(ch)
    for {
        time.Sleep(1000 * time.Millisecond)
        select {
        case v := <-ch:
            fmt.Println("received value: ", v)
            return
        default:
            fmt.Println("no value received")
        }
    }

}
==ex3-deadlock.go========================
package main

func main() {  
    ch := make(chan string)
    select {
    case <-ch:
    }
}
==ex4-deadlock-handling.go========================
package main

import "fmt"

func main() {  
    ch := make(chan string)
    select {
    case <-ch:
    default:
        fmt.Println("default case executed")
    }
}
==ex5.go========================
package main

import "fmt"

func main() {  
    var ch chan string
    select {
    case v := <-ch:
        fmt.Println("received value", v)
    default:
        fmt.Println("default case executed")

    }
}
==ex6-random.go========================
package main

import (  
    "fmt"
    "time"
)

func server1(ch chan string) {  
    ch <- "from server1"
}
func server2(ch chan string) {  
    ch <- "from server2"

}
func main() {  
    output1 := make(chan string)
    output2 := make(chan string)
    go server1(output1)
    go server2(output2)
    time.Sleep(1 * time.Second)
    select {
    case s1 := <-output1:
        fmt.Println(s1)
    case s2 := <-output2:
        fmt.Println(s2)
    }
}
==ex7-select-empty-deadlock.go========================
package main

func main() {  
    select {}
}
==readme.txt========================
What is select?
The select statement is used to choose from multiple send/receive channel operations. The select statement blocks until one of the send/receive operation is ready. If multiple operations are ready, one of them is chosen at random. The syntax is similar to switch except that each of the case statement will be a channel operation. Lets dive right into some code for better understanding.


==911 ..................................==========
==ex1-race-condition.go========================
package main  
import (  
    "fmt"
    "sync"
    )
var x  = 0  
func increment(wg *sync.WaitGroup) {  
    x = x + 1
    wg.Done()
}
func main() {  
    var w sync.WaitGroup
    for i := 0; i < 1000; i++ {
        w.Add(1)        
        go increment(&w)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}
==ex2-race-condition-handling-by-mutex.go========================

package main  
import (  
    "fmt"
    "sync"
    )
var x  = 0  
func increment(wg *sync.WaitGroup, m *sync.Mutex) {  
    m.Lock()
    x = x + 1
    m.Unlock()
    wg.Done()   
}
func main() {  
    var w sync.WaitGroup
    var m sync.Mutex
    for i := 0; i < 1000; i++ {
        w.Add(1)        
        go increment(&w, &m)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}
==ex3-race-condition-handling-by-channel.go========================
package main  
import (  
    "fmt"
    "sync"
    )
var x  = 0  
func increment(wg *sync.WaitGroup, ch chan bool) {  
    ch <- true
    x = x + 1
    <- ch
    wg.Done()   
}
func main() {  
    var w sync.WaitGroup
    ch := make(chan bool, 1)
    for i := 0; i < 1000; i++ {
        w.Add(1)        
        go increment(&w, ch)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}
==readme.txt========================
Mutex vs Channels
We have solved the race condition problem using both mutexes and channels. So how do we decide what to use when. The answer lies in the problem you are trying to solve. If the problem you are trying to solve is a better fit for mutexes then go ahead and use mutex. Do not hesitate to use mutex if needed. If the problem seems to be a better fit for channels, then use it :).

Most Go newbies try to solve every concurrency problem using a channel as it is a cool feature of the language. This is wrong. The language gives us the option to either use Mutex or Channel and there is no wrong in choosing either.

###########################
In general use channels when Goroutines need to communicate with each other and mutexes when only one Goroutine should access the critical section of code.
###########################

In the case of the problem which we solved above, I would prefer to use mutex since this problem does not require any communication between the goroutines. Hence mutex would be a natural fit.

My advice would be to choose the tool for the problem and do not try to fit the problem for the tool :)

This brings us to an end of this tutorial. Have a great day.

==912 ..................................==========
==employee.go========================
package employee

import (  
    "fmt"
)

type Employee struct {  
    FirstName   string
    LastName    string
    TotalLeaves int
    LeavesTaken int
}

func (e Employee) LeavesRemaining() {  
    fmt.Printf("%s %s has %d leaves remaining", e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))
}

/////////////////

type employee struct {  
    firstName   string
    lastName    string
    totalLeaves int
    leavesTaken int
}

func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee {  
    e := employee {firstName, lastName, totalLeave, leavesTaken}
    return e
}

func (e employee) LeavesRemaining() {  
    fmt.Printf("%s %s has %d leaves remaining", e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))
}
==ex1-struct-class.go========================
package main

import (
	"fmt"
	"golanbot2/oops/employee"
)

func main() {
	ex1()
	fmt.Println()
	ex2()
}

func ex1() {
	e := employee.Employee{
		FirstName:   "Manoj",
		LastName:    "kumar",
		TotalLeaves: 30,
		LeavesTaken: 20,
	}
	e.LeavesRemaining()
}

func ex2() {
	//e := employee.Employee{"Manoj", "kumar", 30, 20}

	e := employee.New("Manoj", "kumar", 30, 20)
	e.LeavesRemaining()
}

==ex2-composition-inheritance-1.go========================
package main

import (  
    "fmt"
)

type author struct {  
    firstName string
    lastName  string
    bio       string
}

func (a author) fullName() string {  
    return fmt.Sprintf("%s %s", a.firstName, a.lastName)
}

type post struct {  
    title   string
    content string
    author
}

func (p post) details() {  
    fmt.Println("Title: ", p.title)
    fmt.Println("Content: ", p.content)
    fmt.Println("Author: ", p.fullName())
    fmt.Println("Bio: ", p.bio)
}

//----------------------

func main() {  
    author1 := author{
        "Manoj",
        "Kumar",
        "Golang SSE",
    }
    post1 := post{
        "Inheritance in Go",
        "Go supports composition instead of inheritance",
        author1,
    }
    post1.details()
}
==ex3-composition-inheritance-2.go========================
package main

import (
	"fmt"
)

type author struct {
	firstName string
	lastName  string
	bio       string
}

func (a author) fullName() string {
	return fmt.Sprintf("%s %s", a.firstName, a.lastName)
}

type post struct {
	title   string
	content string
	author
}

func (p post) details() {
	fmt.Println("Title: ", p.title)
	fmt.Println("Content: ", p.content)
	fmt.Println("Author: ", p.fullName())
	fmt.Println("Bio: ", p.bio)
}

type website struct {
	posts []post
}

func (w website) contents() {
	fmt.Println("Contents of Website\n")
	for _, v := range w.posts {
		v.details()
		fmt.Println()
	}
}

//-----------------------------------------------------

func main() {
	author1 := author{
		"Manoj",
		"kumar",
		"SSE",
	}
	post1 := post{
		"aa",
		"aaa",
		author1,
	}
	post2 := post{
		"bb",
		"bbb",
		author1,
	}
	post3 := post{
		"cc",
		"ccc",
		author1,
	}
	w := website{
		posts: []post{post1, post2, post3},
	}
	w.contents()
}

==ex4-polymorphism.go========================
package main

import (
	"fmt"
)

type Income interface {
	calculate() int
	source() string
}

type FixedBilling struct {
	projectName  string
	biddedAmount int
}

type TimeAndMaterial struct {
	projectName string
	noOfHours   int
	hourlyRate  int
}

//--------------

func (fb FixedBilling) calculate() int {
	return fb.biddedAmount
}

func (fb FixedBilling) source() string {
	return fb.projectName
}

func (tm TimeAndMaterial) calculate() int {
	return tm.noOfHours * tm.hourlyRate
}

func (tm TimeAndMaterial) source() string {
	return tm.projectName
}

func calculateNetIncome(ic []Income) {
	var netincome int = 0
	for _, income := range ic {
		fmt.Printf("Income From %s = $%d\n", income.source(), income.calculate())
		netincome += income.calculate()
	}
	fmt.Printf("Net income of organisation = $%d", netincome)
}

//----------------------

func main() {
	project1 := FixedBilling{projectName: "Project 1", biddedAmount: 5000}
	project2 := FixedBilling{projectName: "Project 2", biddedAmount: 10000}
	project3 := TimeAndMaterial{projectName: "Project 3", noOfHours: 160, hourlyRate: 25}
	incomeStreams := []Income{project1, project2, project3}
	calculateNetIncome(incomeStreams)
}

==ex5-polymorphism.go========================
package main

import (
	"fmt"
)

type Income interface {
	calculate() int
	source() string
}

type FixedBilling struct {
	projectName  string
	biddedAmount int
}

type TimeAndMaterial struct {
	projectName string
	noOfHours   int
	hourlyRate  int
}

type Advertisement struct {
	adName     string
	CPC        int
	noOfClicks int
}

func (fb FixedBilling) calculate() int {
	return fb.biddedAmount
}

func (fb FixedBilling) source() string {
	return fb.projectName
}

func (tm TimeAndMaterial) calculate() int {
	return tm.noOfHours * tm.hourlyRate
}

func (tm TimeAndMaterial) source() string {
	return tm.projectName
}

func (a Advertisement) calculate() int {
	return a.CPC * a.noOfClicks
}

func (a Advertisement) source() string {
	return a.adName
}
func calculateNetIncome(ic []Income) {
	var netincome int = 0
	for _, income := range ic {
		fmt.Printf("Income From %s = $%d\n", income.source(), income.calculate())
		netincome += income.calculate()
	}
	fmt.Printf("Net income of organisation = $%d", netincome)
}

func main() {
	project1 := FixedBilling{projectName: "Project 1", biddedAmount: 5000}
	project2 := FixedBilling{projectName: "Project 2", biddedAmount: 10000}
	project3 := TimeAndMaterial{projectName: "Project 3", noOfHours: 160, hourlyRate: 25}
	bannerAd := Advertisement{adName: "Banner Ad", CPC: 2, noOfClicks: 500}
	popupAd := Advertisement{adName: "Popup Ad", CPC: 5, noOfClicks: 750}
	incomeStreams := []Income{project1, project2, project3, bannerAd, popupAd}
	calculateNetIncome(incomeStreams)
}

==go.mod========================
module golanbot2/oops

go 1.13


==913 ..................................==========
==ex1-function.go========================
package main

import (
	"fmt"
)

func finished() {
	fmt.Println("Finished finding largest")
}

func largest(nums []int) {
	defer finished()
	fmt.Println("Started finding largest")
	max := nums[0]
	for _, v := range nums {
		if v > max {
			max = v
		}
	}
	fmt.Println("Largest number in", nums, "is", max)
}

func main() {
	nums := []int{20, 10, 50,30, 40}
	largest(nums)
}

==ex2-method.go========================
package main

import (
	"fmt"
)

type person struct {
	firstName string
	lastName  string
}

func (p person) fullName() {
	fmt.Printf("%s %s", p.firstName, p.lastName)
}

func main() {
	p := person{
		firstName: "aa",
		lastName:  "bb",
	}
	defer p.fullName() //without defer : aa bbWelcome

	fmt.Printf("Welcome ") //Welcome aa bb

}

==ex3-args-evaluation.go========================
package main

import (  
    "fmt"
)

func printA(a int) {  
    fmt.Println("a=", a)
}
func main() {  
    a := 5
    defer printA(a)
    a = 10
    fmt.Println("Before deferred function call a=", a)

}
==ex4-multiple-defer.go========================
package main

import (  
    "fmt"
)

func main() {  
    name := "abcd"
    fmt.Printf("Original String: %s\n", string(name))
    fmt.Printf("Reversed String: ")
    for _, v := range []rune(name) {
        defer fmt.Printf("%c", v)
    }
}
==ex5-uses.go========================
package main

import (
	"fmt"
	"sync"
)

type rect struct {
	length int
	width  int
}

func (r rect) area(wg *sync.WaitGroup) {
	if r.length < 0 {
		fmt.Printf("rect %v's length should be greater than zero\n", r)
		wg.Done()
		return
	}
	if r.width < 0 {
		fmt.Printf("rect %v's width should be greater than zero\n", r)
		wg.Done()
		return
	}
	area := r.length * r.width
	fmt.Printf("rect %v's area %d\n", r, area)
	wg.Done()
}

func main() {
	var wg sync.WaitGroup
	r1 := rect{-67, 89}
	r2 := rect{5, -67}
	r3 := rect{8, 9}
	rects := []rect{r1, r2, r3}
	for _, v := range rects {
		wg.Add(1)
		go v.area(&wg)
	}
	wg.Wait()
	fmt.Println("All go routines finished executing")
}

==ex6-uses-with-defer.go========================
package main

import (
	"fmt"
	"sync"
)

type rect struct {
	length int
	width  int
}

func (r rect) area(wg *sync.WaitGroup) {
	defer wg.Done()
	if r.length < 0 {
		fmt.Printf("rect %v's length should be greater than zero\n", r)
		return
	}
	if r.width < 0 {
		fmt.Printf("rect %v's width should be greater than zero\n", r)
		return
	}
	area := r.length * r.width
	fmt.Printf("rect %v's area %d\n", r, area)
}

func main() {
	var wg sync.WaitGroup
	r1 := rect{-67, 89}
	r2 := rect{5, -67}
	r3 := rect{8, 9}
	rects := []rect{r1, r2, r3}
	for _, v := range rects {
		wg.Add(1)
		go v.area(&wg)
	}
	wg.Wait()
	fmt.Println("All go routines finished executing")
}

==readme.txt========================
What is Defer?
Defer statement is used to execute a function call just before the function where the defer statement is present returns. The definition might seem complex but it's pretty simple to understand by means of an example.


==914 ..................................==========
==custom_err_ex2.go========================
package myerrorhandling

import (  
    "fmt"
    "math"
)

type areaError struct {  
    err    string
    radius float64
}

func (e *areaError) Error() string {  
    return fmt.Sprintf("radius %0.2f: %s", e.radius, e.err)
}


func circleArea2(radius float64) (float64, error) {  
    if radius < 0 {
		//return 0, &areaError{"radius is negative", radius}
		r := areaError{"radius is negative", radius}
		p := &r	
        return 0, p
    }
    return math.Pi * radius * radius, nil
}


/*
func circleArea2(radius float64) (float64, string) {  
    if radius < 0 {
		//return 0, &areaError{"radius is negative", radius}
		r := areaError{"radius is negative", radius}
		p := &r	
        return 0, p.Error()
    }
    return math.Pi * radius * radius, ""
}
*/


func CustomErr2() {  
fmt.Println("\n+++ CustomErr 2 +++++")
    radius := -20.0
    area, err := circleArea2(radius)
    if err != nil {
        if err, ok := err.(*areaError); ok {
            fmt.Printf("Radius %0.2f is less than zero", err.radius)
            return
        }
        fmt.Println(err)
        return
    }
    fmt.Printf("Area of rectangle1 %0.2f\n", area)
}

==custom_err_ex3.go========================
package myerrorhandling

import "fmt"

type areaError3 struct {  
    err    string  //error description
    length float64 //length which caused the error
    width  float64 //width which caused the error
}

func (e *areaError3) Error() string {  
    return e.err
}

func (e *areaError3) lengthNegative() bool {  
    return e.length < 0
}

func (e *areaError3) widthNegative() bool {  
    return e.width < 0
}

func rectArea(length, width float64) (float64, error) {  
    err := ""
    if length < 0 {
        err += "length is less than zero"
    }
    if width < 0 {
        if err == "" {
            err = "width is less than zero"
        } else {
            err += ", width is less than zero"
        }
    }
    if err != "" {
        return 0, &areaError3{err, length, width}
    }
    return length * width, nil
}

func CustomErr3() {  
fmt.Println("\n\n+++ CustomErr 3 +++++")
    length, width := -5.0, -9.0
    area, err := rectArea(length, width)
    if err != nil {
        if err, ok := err.(*areaError3); ok {
            if err.lengthNegative() {
                fmt.Printf("error: length %0.2f is less than zero\n", err.length)

            }
            if err.widthNegative() {
                fmt.Printf("error: width %0.2f is less than zero\n", err.width)

            }
            return
        }
    }
    fmt.Println("area of rect", area)
}
==ex1-error.go========================
package main

import (  
    "fmt"
    "path/filepath"
    "os"
    "net"
)

//Is file exist
func main() {  
    f, err := os.Open("/test.txt")
    if err != nil {
		fmt.Println(err)
       
		fmt.Println(err.Error())
        return
    }
    fmt.Println(f.Name(), "opened successfully")
}

//Is file exist
//https://golang.org/src/os/error.go?s=653:716#L11

func main2() {  
    f, err := os.Open("/test.txt")
    if err, ok := err.(*os.PathError); ok {
		fmt.Println(err)	//err.Error()
        fmt.Println("File at path ==>", err.Path, "<== failed to open")
		
		fmt.Println(err.Op)
		fmt.Println(err.Path)
		fmt.Println(err.Err)

		fmt.Println(err.Error())
		fmt.Println(err.Unwrap())		
        return
    }
    fmt.Println(f.Name(), "opened successfully")
}

//Is host exist
func main3() {  
    addr, err := net.LookupHost("manojkumar.info")
    if err, ok := err.(*net.DNSError); ok {
        if err.Timeout() {
            fmt.Println("operation timed out")
        } else if err.Temporary() {
            fmt.Println("temporary error")
        } else {
            fmt.Println("generic error: ", err)
        }
        return
    }
    fmt.Println(addr)
}

//IsExistFilePath
//https://golang.org/pkg/path/filepath/#Glob
//import "path/filepath"
func main4() {  
    f, err := filepath.Glob("[")
    if err != nil && err == filepath.ErrBadPattern {
        fmt.Println(err)
        return
    }
    fmt.Println("matched files", f)
}

//supress error
func main5() {  
    f, _ := filepath.Glob("[")
    fmt.Println("matched files", f)
}
==ex2-custom-err-extended.go========================
package main

import (
	"fmt"
	"math"
)

func circleArea(radius float64) (float64, error) {
	if radius < 0 {
		return 0, fmt.Errorf("Area calculation failed, radius %0.2f is less than zero", radius)
	}
	return math.Pi * radius * radius, nil
}

func main() {
	radius := -20.0
	area, err := circleArea(radius)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Area of circle %0.2f", area)
}

==ex2-custom-err.go========================
package main

import (
	"errors"
	"fmt"
	"math"
)

func circleArea(radius float64) (float64, error) {
	if radius < 0 {
		return 0, errors.New("Area calculation failed, radius is less than zero")
	}
	return math.Pi * radius * radius, nil
}

func main() {
	radius := -20.0
	area, err := circleArea(radius)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Area of circle %0.2f", area)
}

==ex3-custom-err-struct-extended.go========================
package main

import "fmt"

type areaError struct {  
    err    string  //error description
    length float64 //length which caused the error
    width  float64 //width which caused the error
}

func (e *areaError) Error() string {  
    return e.err
}

func (e *areaError) lengthNegative() bool {  
    return e.length < 0
}

func (e *areaError) widthNegative() bool {  
    return e.width < 0
}

func rectArea(length, width float64) (float64, error) {  
    err := ""
    if length < 0 {
        err += "length is less than zero"
    }
    if width < 0 {
        if err == "" {
            err = "width is less than zero"
        } else {
            err += ", width is less than zero"
        }
    }
    if err != "" {
        return 0, &areaError{err, length, width}
    }
    return length * width, nil
}

func main() {  
    length, width := -5.0, -9.0
    area, err := rectArea(length, width)
    if err != nil {
        if err, ok := err.(*areaError); ok {
            if err.lengthNegative() {
                fmt.Printf("error: length %0.2f is less than zero\n", err.length)

            }
            if err.widthNegative() {
                fmt.Printf("error: width %0.2f is less than zero\n", err.width)

            }
            return
        }
    }
    fmt.Println("area of rect", area)
}
==ex3-custom-err-struct.go========================
package main

import (  
    "fmt"
    "math"
)

type areaError struct {  
    err    string
    radius float64
}

func (e *areaError) Error() string {  
    return fmt.Sprintf("radius %0.2f: %s", e.radius, e.err)
}

func circleArea(radius float64) (float64, error) {  
    if radius < 0 {
        return 0, &areaError{"radius is negative", radius}
    }
    return math.Pi * radius * radius, nil
}

func main() {  
    radius := -20.0
    area, err := circleArea(radius)
    if err != nil {
        if err, ok := err.(*areaError); ok {
            fmt.Printf("Radius %0.2f is less than zero", err.radius)
            return
        }
        fmt.Println(err)
        return
    }
    fmt.Printf("Area of rectangle1 %0.2f", area)
}
==go.mod========================
module golangbot2/error-handling

go 1.13


==915 ..................................==========
==ex1-with-defer.go========================
package main

import (  
    "fmt"
)

func fullName(firstName *string, lastName *string) {  
    defer fmt.Println("deferred call in fullName")
    if firstName == nil {
        panic("runtime error: first name cannot be nil")
    }
    if lastName == nil {
        panic("runtime error: last name cannot be nil")
    }
    fmt.Printf("%s %s\n", *firstName, *lastName)
    fmt.Println("returned normally from fullName")
}

func main() {  
    defer fmt.Println("deferred call in main")
    firstName := "Elon"
    fullName(&firstName, nil)
    fmt.Println("returned normally from main")
}
==ex1.go========================
package main

import (  
    "fmt"
)

func fullName(firstName *string, lastName *string) {  
    if firstName == nil {
        panic("runtime error: first name cannot be nil")
    }
    if lastName == nil {
        panic("runtime error: last name cannot be nil")
    }
    fmt.Printf("%s %s\n", *firstName, *lastName)
    fmt.Println("returned normally from fullName")
}

func main() {  
    firstName := "Elon"
    fullName(&firstName, nil)
    fmt.Println("returned normally from main")
}
==ex2-recover.go========================
package main

import (  
    "fmt"
)

func recoverName() {  
    if r := recover(); r!= nil {
        fmt.Println("recovered from ", r)
    }
}

func fullName(firstName *string, lastName *string) {  
    defer recoverName()
    if firstName == nil {
        panic("runtime error: first name cannot be nil")
    }
    if lastName == nil {
        panic("runtime error: last name cannot be nil")
    }
    fmt.Printf("%s %s\n", *firstName, *lastName)
    fmt.Println("returned normally from fullName")
}

func main() {  
    defer fmt.Println("deferred call in main")
    firstName := "Elon"
    fullName(&firstName, nil)
    fmt.Println("returned normally from main")
}
==ex3-panic-goroutine.go========================
package main

import (  
    "fmt"
    "time"
)

func recovery() {  
    if r := recover(); r != nil {
        fmt.Println("recovered:", r)
    }
}

func a() {  
    defer recovery()
    fmt.Println("Inside A")	
    go b() //goroutine - not recovered	
    //b()  //function - recovered
	//because the recovery function is present in a different gouroutine and the panic is happening in a different goroutine.
    time.Sleep(1 * time.Second)
}


func b() {  
    fmt.Println("Inside B")
    panic("oh! B panicked")
}

func main() {  
    a()
    fmt.Println("normally returned from main")
}
==ex4-panic-runtime-recover.go========================
package main

import (  
    "fmt"
)

func r() {  
    if r := recover(); r != nil {
        fmt.Println("Recovered", r)
    }
}

func a() {  
    defer r()
    n := []int{5, 7, 4}
    fmt.Println(n[3])
    fmt.Println("normally returned from a")
}

func main() {  
    a()
    fmt.Println("normally returned from main")
}
==ex4-panic-runtime.go========================
package main
import "fmt"
/*
type Error interface {  
    error
    // RuntimeError is a no-op function but
    // serves to distinguish types that are run time
    // errors from ordinary errors: a type is a
    // run time error if it has a RuntimeError method.
    RuntimeError()
}
*/

func a() {  
    n := []int{5, 7, 4}
    fmt.Println(n[3])
    fmt.Println("normally returned from a")
}
func main() {  
    a()
    fmt.Println("normally returned from main")
}
==ex5.go========================
/*
Getting stack trace after recover
If we recover a panic, we loose the stack trace about the panic. Even in the program above after recovery, we lost the stack trace.

There is a way to print the stack trace using the PrintStack function of the Debug package

*/

package main

import (  
    "fmt"
  //  "runtime/debug"
)

func r() {  
    if r := recover(); r != nil {
        fmt.Println("Recovered", r)
     //   debug.PrintStack()
    }
}

func a() {  
    defer r()
    n := []int{5, 7, 4}
    fmt.Println(n[3])
    fmt.Println("normally returned from a")
}

func main() {  
    a()
    fmt.Println("normally returned from main")
}

==916 ..................................==========
==ex1-anonymous.go========================
package main

import (
	"fmt"
)

func main1() {
	a := func() {
		fmt.Println("hello world first class function")
	}
	a()
	fmt.Printf("%T", a)
}

func main2() {
	func() {
		fmt.Println("hello world first class function")
	}()
}

func main() {
	func(n string) {
		fmt.Println("Welcome", n)
	}("Gophers")
}

==ex2-user-defined.go========================
package main

import (  
    "fmt"
)

type add func(a int, b int) int

func main() {  
    var a add = func(a int, b int) int {
        return a + b
    }
    s := a(5, 6)
    fmt.Println("Sum", s)
}
==ex3-high-order.go========================
package main

import (  
    "fmt"
)

func simple(a func(a, b int) int) {  
    fmt.Println(a(60, 7))
}

func main() {  
    f := func(a, b int) int {
        return a + b
    }
    simple(f)
}
==ex4-returning-fun-other-fun.go========================
package main

import (  
    "fmt"
)

func simple() func(a, b int) int {  
    f := func(a, b int) int {
        return a + b
    }
    return f
}

func main() {  
    s := simple()
    fmt.Println(s(10, 20))
}

==917 ..................................==========
==ex1.go========================
package main

import (  
    "fmt"
)

func main() {  
    i := 10
    fmt.Printf("%d %T", i, i)
}
==ex2.go========================
package main

import (  
    "fmt"
)

type order struct {  
    ordId      int
    customerId int
}


func (o order) String() string {
	return fmt.Sprintf("%d, %d", o.ordId, o.customerId)
}


func createQuery(o order) string {  
    i := fmt.Sprintf("insert into order values(%d, %d)", o.ordId, o.customerId)
    return i
}


func main() {  
    o := order{
        ordId:      11,
        customerId: 22,
    }
	
	//String() automatically called
    fmt.Println(o)	// {11 22} or 11, 22

	fmt.Println(createQuery(o))
}
==ex3-type-value.go========================
package main

import (  
    "fmt"
    "reflect"
)

type order struct {  
    ordId      int
    customerId int
}

func createQuery(q interface{}) {  
    t := reflect.TypeOf(q)
    v := reflect.ValueOf(q)
    fmt.Println("Type ", t)
    fmt.Println("Value ", v)


}
func main() {  
    o := order{
        ordId:      456,
        customerId: 56,
    }
    createQuery(o)

}
==ex4-kind.go========================
package main

import (  
    "fmt"
    "reflect"
)

type order struct {  
    ordId      int
    customerId int
}

func createQuery(q interface{}) {  
    t := reflect.TypeOf(q)
    k := t.Kind()
    fmt.Println("Type ", t)
    fmt.Println("Kind ", k)


}
func main() {  
    o := order{
        ordId:      456,
        customerId: 56,
    }
    createQuery(o)

}
==ex5-numfield.go========================
package main

import (  
    "fmt"
    "reflect"
)

type order struct {  
    ordId      int
    customerId int
}

func createQuery(q interface{}) {  
    if reflect.ValueOf(q).Kind() == reflect.Struct {
        v := reflect.ValueOf(q)
        fmt.Println("Number of fields", v.NumField())
        for i := 0; i < v.NumField(); i++ {
            fmt.Printf("Field:%d type:%T value:%v\n", i, v.Field(i), v.Field(i))
        }
    }

}
func main() {  
    o := order{
        ordId:      456,
        customerId: 56,
    }
    createQuery(o)
}
==ex6-int.go========================
package main

import (  
    "fmt"
    "reflect"
)

func main() {  
    a := 10
    x := reflect.ValueOf(a).Int()
    fmt.Printf("type:%T value:%v\n", x, x)
	
	
    b := "aa"
    y := reflect.ValueOf(b).String()
    fmt.Printf("type:%T value:%v\n", y, y)

}
==ex7.go========================
package main

import (  
    "fmt"
    "reflect"
)

type order struct {  
    ordId      int
    customerId int
}

type employee struct {  
    name    string
    id      int
    address string
    salary  int
    country string
}

func createQuery(q interface{}) {  
    if reflect.ValueOf(q).Kind() == reflect.Struct {
        t := reflect.TypeOf(q).Name()
        query := fmt.Sprintf("insert into %s values(", t)
        v := reflect.ValueOf(q)
        for i := 0; i < v.NumField(); i++ {
            switch v.Field(i).Kind() {
            case reflect.Int:
                if i == 0 {
                    query = fmt.Sprintf("%s%d", query, v.Field(i).Int())
                } else {
                    query = fmt.Sprintf("%s, %d", query, v.Field(i).Int())
                }
            case reflect.String:
                if i == 0 {
                    query = fmt.Sprintf("%s\"%s\"", query, v.Field(i).String())
                } else {
                    query = fmt.Sprintf("%s, \"%s\"", query, v.Field(i).String())
                }
            default:
                fmt.Println("Unsupported type")
                return
            }
        }
        query = fmt.Sprintf("%s)", query)
        fmt.Println(query)
        return

    }
    fmt.Println("unsupported type")
}

func main() {  
    o := order{
        ordId:      456,
        customerId: 56,
    }
    createQuery(o)

    e := employee{
        name:    "Naveen",
        id:      565,
        address: "Coimbatore",
        salary:  90000,
        country: "India",
    }
    createQuery(e)
    i := 90
    createQuery(i)

}

